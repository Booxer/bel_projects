--! @file        pmc_ctrl_auto.vhd
--  DesignUnit   pmc_ctrl_auto
--! @author      A. Hahn <a.hahn@gsi.de>
--! @date        30/01/2015
--! @version     0.0.1
--! @copyright   2015 GSI Helmholtz Centre for Heavy Ion Research GmbH
--!

--! @brief AUTOGENERATED WISHBONE-SLAVE CORE FOR pmc_ctrl.vhd
--!
--------------------------------------------------------------------------------
--! This library is free software; you can redistribute it and/or
--! modify it under the terms of the GNU Lesser General Public
--! License as published by the Free Software Foundation; either
--! version 3 of the License, or (at your option) any later version.
--!
--! This library is distributed in the hope that it will be useful,
--! but WITHOUT ANY WARRANTY; without even the implied warranty of
--! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
--! Lesser General Public License for more details.
--!
--! You should have received a copy of the GNU Lesser General Public
--! License along with this library. If not, see <http://www.gnu.org/licenses/>.
--------------------------------------------------------------------------------

-- ***********************************************************
-- ** WARNING - THIS IS AUTO-GENERATED CODE! DO NOT MODIFY! **
-- ***********************************************************
--
-- If you want to change the interface,
-- modify pmc_ctrl.xml and re-run 'python wbgenplus.py pmc_ctrl.xml' !

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.wishbone_pkg.all;
use work.pmc_ctrl_auto_pkg.all;

entity pmc_ctrl_auto is
Port(
   clk_sys_i      : in  std_logic;
   rst_n_i        : in  std_logic;

   slave_regs_i   : in  t_slave_regs_i;
   slave_regs_o   : out t_slave_regs_o;
   
   slave_i        : in  t_wishbone_slave_in  := ('0', '0', x"00000000", x"F", '0', x"00000000");
   slave_o        : out t_wishbone_slave_out
   
);
end pmc_ctrl_auto;

architecture rtl of pmc_ctrl_auto is

   --+******************************************************************************************+
   --|  ------------------------------------- WB Registers -------------------------------------|
   --+******************************************************************************************+

   --| WBS Regs ---------------------------- slave ---------------------------------------------|
   signal r_slave             : t_slave_regs_o;
   signal s_slave             : t_slave_regs_i;
   signal r_slave_out_stall   : std_logic;
   signal r_slave_out_ack0,
          r_slave_out_ack1,
          r_slave_out_err0,
          r_slave_out_err1    : std_logic;
   signal r_slave_out_dat0,
          r_slave_out_dat1    : std_logic_vector(31 downto 0);



begin

   --+******************************************************************************************+
   --| WBS FSM ------------------------------ slave --------------------------------------------|
   --+******************************************************************************************+
   slave : process(clk_sys_i)
      variable v_dat_i  : t_wishbone_data;
      variable v_dat_o  : t_wishbone_data;
      variable v_adr    : natural;
      variable v_page   : natural;
      variable v_sel    : t_wishbone_byte_select;
      variable v_we     : std_logic;
      variable v_en     : std_logic;
   begin
      if rising_edge(clk_sys_i) then
         if(rst_n_i = '0') then
            r_slave.CLOCK_CONTROL   <= (others => '0');
            r_slave_out_stall       <= '0';
            r_slave_out_ack0        <= '0';
            r_slave_out_err0        <= '0';
            r_slave_out_dat0        <= (others => '0');
            r_slave_out_ack1        <= '0';
            r_slave_out_err1        <= '0';
            r_slave_out_dat1        <= (others => '0');
         else
            -- short names
            v_dat_i           := slave_i.dat;
            v_adr             := to_integer(unsigned(slave_i.adr(2 downto 2)) & "00");
            v_sel             := slave_i.sel;
            v_en              := slave_i.cyc and slave_i.stb and not (r_slave_out_stall or slave_regs_i.STALL);
            v_we              := slave_i.we;

            --interface outputs
            r_slave_out_stall   <= '0';
            r_slave_out_ack0    <= '0';
            r_slave_out_err0    <= '0';
            r_slave_out_dat0    <= (others => '0');

            r_slave_out_ack1    <= r_slave_out_ack0;
            r_slave_out_err1    <= r_slave_out_err0;
            r_slave_out_dat1    <= r_slave_out_dat0;

            
            if(v_en = '1') then
               r_slave_out_ack0  <= '1';
               if(v_we = '1') then
                  -- WISHBONE WRITE ACTIONS
                  case v_adr is
                     when c_slave_CLOCK_CONTROL_OWR   => r_slave.CLOCK_CONTROL   <= f_wb_wr(r_slave.CLOCK_CONTROL,   v_dat_i, v_sel, "owr"); -- Control external clock enable
                     when others => r_slave_out_ack0 <= '0'; r_slave_out_err0 <= '1';
                  end case;
               else
                  -- WISHBONE READ ACTIONS
                  case v_adr is
                     when c_slave_HEX_SWITCH_GET   => r_slave_out_dat0(3 downto 0)  <= s_slave.HEX_SWITCH;  -- Shows hex switch inputs
                     when others => r_slave_out_ack0 <= '0'; r_slave_out_err0 <= '1';
                  end case;
               end if; -- v_we
            end if; -- v_en
         end if; -- rst
      end if; -- clk edge
   end process;

   slave_regs_o   <= r_slave;
   s_slave        <= slave_regs_i;
   slave_o.stall  <= r_slave_out_stall or slave_regs_i.STALL;
   slave_o.dat    <= r_slave_out_dat1;
   slave_o.ack    <= r_slave_out_ack1 and not slave_regs_i.ERR;
   slave_o.err    <= r_slave_out_err1 or      slave_regs_i.ERR;


end rtl;
