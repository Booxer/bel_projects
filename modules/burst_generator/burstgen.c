/********************************************************************************************
 *  burstgen.c (based on lm32 example)
 *
 *  created : 2019, GSI Darmstadt
 *  author  : Dietrich Beck, Enkhbold Ochirsuren
 *  version : 14-Feb-2019
 *
 *  example program for lm32 softcore
 *
 *  build : make clean && make TARGET=burstgen
 *  deploy : scp burstgen.bin root@scuxl0304.acc:.
 *
 * -------------------------------------------------------------------------------------------
 * License Agreement for this software:
 *
 * Copyright (C) 2017  Dietrich Beck
 * GSI Helmholtzzentrum für Schwerionenforschung GmbH
 * Planckstraße 1
 * D-64291 Darmstadt
 * Germany
 *
 * Contact: d.beck@gsi.de
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 3 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library. If not, see <http://www.gnu.org/licenses/>.
 *
 * For all questions and ideas contact: d.beck@gsi.de
 * Last update: 25-April-2015
 ********************************************************************************************/

/* standard includes */
#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include <stdint.h>

/* includes specific for bel_projects */
#include "mprintf.h"
#include "mini_sdb.h"
#include "aux.h"
#include "dbg.h"
#include "syscon.h"


/* register maps for some selected Wishbone devices  */
#include "../../tools/wb_slaves.h" /* this is a hack */
#include "../../ip_cores/wr-cores/modules/wr_eca/eca_regs.h"
#include "../../ip_cores/saftlib/drivers/eca_flags.h"
#include "../../ip_cores/wr-cores/modules/wr_eca/eca_queue_regs.h"
#include "../wr-unipz/include/wr-unipz.h"

/* definitions of LM32 action events */
#define MY_ECA_TAG  0x42  // ECA actions tagged for me
uint32_t myTimingEvent[8];
void injectTimingEvent(uint32_t *msg);

// ECA rules for IO channel for burst
typedef struct {
  uint32_t nConditions; // number of ECA conditions
  uint32_t tOffset;     // and their offsets
} ecaIoRules_s;

// desired pulse frequencies
enum {
  M_12_5 = 0, // 12,5 MHz
  M_10,      // 10 MHz
  M_2,       // 2 MHz
  M_1,       // 1 MHz
  K_500,     // 500 Khz
  K_100,     // 100 KHz
  K_10,      // 10 KHz
  K_1,       // 1 KHz
  N_FREQ
};

// pulse generation based on ECA IO rules
ecaIoRules_s ioPulses[N_FREQ] = {
  {250,40}, {200,50}, {100,250}, {100,500}, {100,1000}, {100,5000}, {10,50000}, {10,500000}};
/* 12,5 MHz, 10 MHz,   2 MHz,     1 MHz,     500 KHz,    100 KHz,    10 KHz,     1 KHz */

/* shared memory map for communication via Wishbone  */
#include <burstgen_shared_mmap.h>        // autogenerated upon building firmware

#define NWORDS 2048                          // WARNING: don't exceed 'shared size'! A value of 1024 already requires 8k!

/* stuff required for environment */
extern uint32_t*       _startshared[];
unsigned int cpuId, cpuQty;
#define SHARED __attribute__((section(".shared")))
uint64_t SHARED dummy = 0;

// global variables
volatile uint32_t *pEcaCtl;         // WB address of ECA control
volatile uint32_t *pEca;            // WB address of ECA event input (discoverPeriphery())
volatile uint32_t *pECAQ;           // WB address of ECA queue
volatile uint32_t *pPsram;          // WB address of psram
volatile uint32_t *pPsram1;         // pointer to buffer in pseudo ram
volatile uint32_t *pPsram2;         // pointer to buffer in pseudo ram
volatile uint32_t *pShared;         // pointer to begin of shared memory region
volatile uint32_t *pSharedBuff1;    // pointer to buffer in shared memory
volatile uint32_t *pSharedBuff2;    // pointer to buffer in shared memory
volatile uint32_t *pCpuRamExternal; // external address (seen from host bridge) of this CPU's RAM

void init()
{
  discoverPeriphery();    // mini-sdb: get info on important Wishbone infrastructure, such as (this) CPU, flash, ...

  mprintf("Found MsgBox at 0x%08x. MSI Path is 0x%08x\n", (uint32_t)pCpuMsiBox, (uint32_t)pMyMsi);

  uart_init_hw();         // init UART, required for printf... . To view print message, you may use 'eb-console' from the host
  cpuId = getCpuIdx();    // get ID of THIS CPU

  pEcaCtl = find_device_adr(ECA_SDB_VENDOR_ID, ECA_SDB_DEVICE_ID);

  timer_init(1);          // needed by usleep_init()
  usleep_init();          // needed by scu_mil.c

  //isr_table_clr();        // set MSI IRQ handler
  //irq_set_mask(0x01);     // ...
  //irq_disable();          // ...
} // init


/***********************************************************
 *
 * demonstrate exchange of data to Wishbone via shared RAM
 * - the data can be accessed via Etherbone->Wishbone
 * - try eb-read/eb-write from the host system
 *
 ***********************************************************/
void initSharedMem()
{
  uint32_t i,j;
  uint32_t idx;
  const uint32_t c_Max_Rams = 10;
  sdb_location found_sdb[c_Max_Rams];
  sdb_location found_clu;

  // get pointer to shared memory; internal perspective of this LM32
  pShared        = (uint32_t *)_startshared;                // begin of shared mem
  pSharedBuff1   = (uint32_t *)(pShared +      0);          // 1st buffer in shared memory
  pSharedBuff2   = (uint32_t *)(pShared + NWORDS);          // 2nd buffer in shared memory

  // print pointer info to UART
  mprintf("burstgen: internal shared memory: start            @ 0x%08x\n", (uint32_t)pShared);

  // get pointer to shared memory; external perspective from host bridge
  idx = 0;
  find_device_multi(&found_clu, &idx, 1, GSI, LM32_CB_CLUSTER);
  idx = 0;
  find_device_multi_in_subtree(&found_clu, &found_sdb[0], &idx, c_Max_Rams, GSI, LM32_RAM_USER);
  if(idx >= cpuId) {
    pCpuRamExternal = (uint32_t*)(getSdbAdr(&found_sdb[cpuId]) & 0x7FFFFFFF); // CPU sees the 'world' under 0x8..., remove that bit to get host bridge perspective
    // print external WB info to UART
    mprintf("burstgen: external shared memory: start            @ 0x%08x\n", (uint32_t)(pCpuRamExternal + (SHARED_OFFS >> 2)));
  } else {
    pCpuRamExternal = (uint32_t*)ERROR_NOT_FOUND;
    mprintf("burstgen: could not find external WB address of my own RAM !\n");
  }
} // useSharedMem

uint32_t findEcaQueue() // find WB address of ECA channel for LM32
{
#define ECAQMAX           4     // max number of ECA channels in the system
#define ECACHANNELFORLM32 2     // this is a hack! suggest implementing finding via sdb-record and info

  // stuff below needed to get WB address of ECA queue
  sdb_location EcaQ_base[ECAQMAX];
  uint32_t EcaQ_idx = 0;
  uint32_t *tmp;
  int i;

  // get Wishbone address of ECA queue
  // get list of ECA queues
  find_device_multi(EcaQ_base, &EcaQ_idx, ECAQMAX, ECA_QUEUE_SDB_VENDOR_ID, ECA_QUEUE_SDB_DEVICE_ID);
  pECAQ = 0x0;

  // find ECA queue connected to ECA channel for LM32
  for (i=0; i < EcaQ_idx; i++) {
    tmp = (uint32_t *)(getSdbAdr(&EcaQ_base[i]));
    mprintf("-- found ECA queue%d @ 0x%08x\n", i, (uint32_t)tmp);
    if ( *(tmp + (ECA_QUEUE_QUEUE_ID_GET >> 2)) == ECACHANNELFORLM32) {
      pECAQ = tmp;
      i = EcaQ_idx;
    }
  }

  if (pECAQ)
    return WRUNIPZ_STATUS_OK;
  else
    return WRUNIPZ_STATUS_ERROR;
} // findEcaQueue

/*************************************************************
*
* poll action events from an ECA queue for LM32
* HERE: poll ECA, get data of action and do something
*
* This example assumes that
* - action for this lm32 are configured by using saft-ecpu-ctl
*   from the host system
* - a TAG with value 0x4 has been configure (see saft-ecpu-ctl -h
*   for help
*
**************************************************************/
void ecaHandler()
{
  uint32_t flag;                // flag for the next action
  uint32_t evtIdHigh;           // high 32bit of eventID
  uint32_t evtIdLow;            // low 32bit of eventID
  uint32_t evtDeadlHigh;        // high 32bit of deadline
  uint32_t evtDeadlLow;         // low 32bit of deadline
  uint32_t actTag;              // tag of action

  // read flag and check if there was an action
  flag         = *(pECAQ + (ECA_QUEUE_FLAGS_GET >> 2));
  if (flag & (0x0001 << ECA_VALID)) {
    // read data
    evtIdHigh    = *(pECAQ + (ECA_QUEUE_EVENT_ID_HI_GET >> 2));
    evtIdLow     = *(pECAQ + (ECA_QUEUE_EVENT_ID_LO_GET >> 2));
    evtDeadlHigh = *(pECAQ + (ECA_QUEUE_DEADLINE_HI_GET >> 2));
    evtDeadlLow  = *(pECAQ + (ECA_QUEUE_DEADLINE_LO_GET >> 2));
    actTag       = *(pECAQ + (ECA_QUEUE_TAG_GET >> 2));

    // pop action from channel
    *(pECAQ + (ECA_QUEUE_POP_OWR >> 2)) = 0x1;

    // here: do s.th. according to action
    switch (actTag) {
    case MY_ECA_TAG:
      mprintf("EvtID: 0x%08x%08x; deadline: 0x%08x%08x; flag: 0x%08x\n", evtIdHigh, evtIdLow, evtDeadlHigh, evtDeadlLow, flag);
      injectTimingEvent(myTimingEvent); // inject timing event for generating pulses
      break;
    default:
      mprintf("ecaHandler: unknown tag\n");
    } // switch

  } // if data is valid
} // ecaHandler

/***********************************************************
 *
 * construct a timing event for ECA input
 *
 ***********************************************************/
void constructTimingEvent(uint32_t *msg)
{
    // construct an event
    *msg = 0xEEEE0000; // FID+GID*EVTNO+flags
    *(msg +1) = 0x0; // SID+BPID+resrv
    *(msg +2) = 0x0; // param_up
    *(msg +3) = 0x0; // param_lo
    *(msg +4) = 0x0; // resrv
    *(msg +5) = 0x0; // TEF
    *(msg +6) = 0x0;
    *(msg +7) = 0x0;

    mprintf("\ninject event\n");
    mprintf("event: %x-%x\n",msg[0], msg[1]);
    mprintf("param: %x-%x\n",msg[2], msg[3]);
    mprintf("resrv: %x\n",msg[4]);
    mprintf("TEF  : %x\n",msg[5]);
}


/***********************************************************
 *
 * inject a timing event to ECA input locally
 * get White Rabbit time from ECA
 *
 ***********************************************************/
void injectTimingEvent(uint32_t *msg)
{
    atomic_on();
    *pEca = msg[0];
    *pEca = msg[1];
    *pEca = msg[2];
    *pEca = msg[3];
    *pEca = msg[4];
    *pEca = msg[5];
    *pEca = msg[6];
    *pEca = msg[7];
    atomic_off();
}

void main(void) {
  uint32_t i, j, nEvnt = 5;

  uint64_t t1, t2, tPeriod, tInject, tWait, tDeadline;
  uint32_t dt1, dt2, dt3, dt4, dt5, dt6, dt7, dt8;

  uint32_t data1, data2, data3, data4, data5, data6, data7, data8;

  data1 = 0xdeadbeef;
  data2 = 0xcafebabe;

  init();                     // initialize 'boot' lm32
  initSharedMem();            // init shared memory

  // report address of all required WB devices if they were detected, otherwise exit
  if (pEcaCtl) mprintf("Addr of ECA control: 0x%08x\n", (uint32_t) pEcaCtl);
  else      {  mprintf("ECA control addr is not found\n"); return;}

  if (pEca)    mprintf("Addr of ECA event input: 0x%08x\n", (uint32_t) pEca);
  else      {  mprintf("ECA event input is not found\n");  return;}

  if (findEcaQueue() == WRUNIPZ_STATUS_OK)
         mprintf("Addr of ECA queue connected to ECA channel for LM32: 0x%08x\n", (uint32_t) pECAQ);
  else { mprintf("ECA queue connected to ECA channel for LM32 is not found\n");  return;}

  constructTimingEvent(myTimingEvent); // construct a timing event

  // set time interval needed for sending timing event periodically
  ecaIoRules_s *pulse = &ioPulses[K_500]; // generate pulses with the chosen frequency (stable up to 500KHz)
  tPeriod = pulse->nConditions * pulse->tOffset;

  // set up event injection
  t1 = getSysTime();
  tDeadline = getSysTime() + tPeriod; // set initial deadline

  *(myTimingEvent +6) = (uint32_t)((tDeadline >> 32) & 0xFFFFFFFF);
  *(myTimingEvent +7) = (uint32_t)(tDeadline & 0xFFFFFFFF);

  // inject the first event
  injectTimingEvent(myTimingEvent);

  tInject = getSysTime() - t1; // get injection duration
  tInject <<= 1;

  // repeat the injection
#if 1
  while(1) {
#else
  for (i = 0; i < nEvnt; i++) {
#endif

    tDeadline += tPeriod;   // set next deadline
    *(myTimingEvent +6) = (uint32_t)((tDeadline >> 32) & 0xFFFFFFFF);
    *(myTimingEvent +7) = (uint32_t)(tDeadline & 0xFFFFFFFF);

    do {
      t1 = tDeadline - getSysTime();
    } while (t1 > tInject); // wait until setup due

    injectTimingEvent(myTimingEvent);
  }

#if 0
  // write to shared ram
  t1 = getSysTime();
  for (i=0; i<NWORDS; i++) {
    pSharedBuff1[i] = data1;
  } // for i
  t2 = getSysTime();
  dt1 = (uint32_t)(t2 -t1);

  // copy between shared ram buffers
  t1 = getSysTime();
  for (i=0; i<NWORDS; i++) {
    pSharedBuff2[i] = pSharedBuff1[i];
  } // for i
  t2 = getSysTime();
  dt2 = (uint32_t)(t2 -t1);

  // read from shared ram and check values
  for (i=0; i<NWORDS; i++) {
    if (pSharedBuff2[i] != data1) mprintf("burstgen: shared mem messed up\n");
  } // for i

  // read from shared ram
  t1 = getSysTime();
  for (i=0; i<NWORDS; i++) {
    if (data3 = pSharedBuff2[i]);
  } // for i
  t2    = getSysTime();
  dt3   = (uint32_t)(t2 -t1);

  mprintf("writing %d * 0x%x (32bit) took %7u ns or %4u ns/word or %4u Mbit/s (shared ram)\n",       NWORDS, data1, dt1, dt1/(NWORDS), (1000 * NWORDS * 32)/dt1);
  mprintf("copying %d * 0x%x (32bit) took %7u ns or %4u ns/word or %4u Mbit/s (shared -> shared)\n", NWORDS, data1, dt2, dt2/(NWORDS), (1000 * NWORDS * 32)/dt2);
  mprintf("reading %d * 0x%x (32bit) took %7u ns or %4u ns/word or %4u Mbit/s (shared ram)\n",       NWORDS, data3, dt3, dt3/(NWORDS), (1000 * NWORDS * 32)/dt3);
#endif

}  /* main */
