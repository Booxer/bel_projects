/********************************************************************************************
 *  psramexample.c
 *
 *  created : 2019
 *  author  : Dietrich Beck GSI-Darmstadt
 *  version : 14-Feb-2019
 *
 *  example program for lm32 softcore
 * 
 *  demonstrates copying data from shared memory (lm32) to external pseudo-SRAM
 *  psram is available on the exploder5
 *
 * -------------------------------------------------------------------------------------------
 * License Agreement for this software:
 *
 * Copyright (C) 2017  Dietrich Beck
 * GSI Helmholtzzentrum für Schwerionenforschung GmbH
 * Planckstraße 1
 * D-64291 Darmstadt
 * Germany
 *
 * Contact: d.beck@gsi.de
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 3 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *  
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library. If not, see <http://www.gnu.org/licenses/>.
 *
 * For all questions and ideas contact: d.beck@gsi.de
 * Last update: 25-April-2015
 ********************************************************************************************/

/* standard includes */
#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include <stdint.h>

/* includes specific for bel_projects */
#include "mprintf.h"
#include "mini_sdb.h"
#include "aux.h"
#include "dbg.h"
#include "syscon.h"


/* register maps for some selected Wishbone devices  */
#include "../../tools/wb_slaves.h" /* this is a hack */

/* shared memory map for communication via Wishbone  */
#include <psramexample_shared_mmap.h>        // autogenerated upon building firmware

#define NWORDS 2048                          // WARNING: don't exceed 'shared size'! A value of 1024 already requires 8k!

/* stuff required for environment */
extern uint32_t*       _startshared[];
unsigned int cpuId, cpuQty;
#define SHARED __attribute__((section(".shared")))
uint64_t SHARED dummy = 0;


volatile uint32_t *pPsram;          // WB address of psram
volatile uint32_t *pPsram1;         // pointer to buffer in pseudo ram
volatile uint32_t *pPsram2;         // pointer to buffer in pseudo ram
volatile uint32_t *pShared;         // pointer to begin of shared memory region
volatile uint32_t *pSharedBuff1;    // pointer to buffer in shared memory 
volatile uint32_t *pSharedBuff2;    // pointer to buffer in shared memory 
volatile uint32_t *pCpuRamExternal; // external address (seen from host bridge) of this CPU's RAM

void init()
{
  discoverPeriphery();    // mini-sdb: get info on important Wishbone infrastructure, such as (this) CPU, flash, ...
  uart_init_hw();         // init UART, required for printf... . To view print message, you may use 'eb-console' from the host
  cpuId = getCpuIdx();    // get ID of THIS CPU

  timer_init(1);          // needed by usleep_init() 
  usleep_init();          // needed by scu_mil.c
  
  isr_table_clr();        // set MSI IRQ handler
  irq_set_mask(0x01);     // ...
  irq_disable();          // ...
} // init


void findPsram() 
{
  pPsram = 0x0;
  
  // get Wishbone address for Pseudo SRAM
  pPsram = find_device_adr(PSRAM_VENDOR, PSRAM_PRODUCT);

  if (!pPsram) mprintf("psramexample: can't find Pseudo RAM\n");
} // findPsram


/***********************************************************
 *
 * demonstrate exchange of data to Wishbone via shared RAM 
 * - the data can be accessed via Etherbone->Wishbone
 * - try eb-read/eb-write from the host system
 *
 ***********************************************************/
void initSharedMem()
{
  uint32_t i,j;
  uint32_t idx;
  const uint32_t c_Max_Rams = 10;
  sdb_location found_sdb[c_Max_Rams];
  sdb_location found_clu;

  // get pointer to shared memory; internal perspective of this LM32
  pShared        = (uint32_t *)_startshared;                // begin of shared mem
  pSharedBuff1   = (uint32_t *)(pShared +      0);          // 1st buffer in shared memory
  pSharedBuff2   = (uint32_t *)(pShared + NWORDS);          // 2nd buffer in shared memory

  // print pointer info to UART
  mprintf("psramexample: internal shared memory: start            @ 0x%08x\n", (uint32_t)pShared);

  // get pointer to shared memory; external perspective from host bridge
  idx = 0;
  find_device_multi(&found_clu, &idx, 1, GSI, LM32_CB_CLUSTER);	
  idx = 0;
  find_device_multi_in_subtree(&found_clu, &found_sdb[0], &idx, c_Max_Rams, GSI, LM32_RAM_USER);
  if(idx >= cpuId) {
    pCpuRamExternal = (uint32_t*)(getSdbAdr(&found_sdb[cpuId]) & 0x7FFFFFFF); // CPU sees the 'world' under 0x8..., remove that bit to get host bridge perspective
    // print external WB info to UART
    mprintf("psramexample: external shared memory: start            @ 0x%08x\n", (uint32_t)(pCpuRamExternal + (SHARED_OFFS >> 2)));
  } else {
    pCpuRamExternal = (uint32_t*)ERROR_NOT_FOUND;
    mprintf("psramexample: could not find external WB address of my own RAM !\n");
  }
} // useSharedMem


void main(void) {
  uint32_t i;

  
  uint64_t t1, t2;  
  uint32_t dt1, dt2, dt3, dt4, dt5, dt6, dt7, dt8;

  uint32_t data1, data2, data3, data4, data5, data6, data7, data8;

  data1 = 0xdeadbeef;
  data2 = 0xcafebabe;

  
  init();                     // initialize 'boot' lm32
  initSharedMem();            // init shared memory

  findPsram();                // find pseudo sram
  pPsram1 = pPsram;           // 1st buffer in pseudo sram
  pPsram2 = pPsram + NWORDS;  // 2nd buffer in pseudo sram

  // write to shared ram
  t1 = getSysTime();
  for (i=0; i<NWORDS; i++) {
    pSharedBuff1[i] = data1;
  } // for i 
  t2 = getSysTime();
  dt1 = (uint32_t)(t2 -t1);

  // copy between shared ram buffers
  t1 = getSysTime();
  for (i=0; i<NWORDS; i++) {
    pSharedBuff2[i] = pSharedBuff1[i];
  } // for i 
  t2 = getSysTime();
  dt2 = (uint32_t)(t2 -t1);

  // read from shared ram and check values
  for (i=0; i<NWORDS; i++) {
    if (pSharedBuff2[i] != data1) mprintf("psramexample: shared mem messed up\n");
  } // for i 

  // read from shared ram 
  t1 = getSysTime();
  for (i=0; i<NWORDS; i++) {
    if (data3 = pSharedBuff2[i]);
  } // for i 
  t2    = getSysTime();
  dt3   = (uint32_t)(t2 -t1);
  
  // write to pseudo sram
  t1 = getSysTime();
  for (i=0; i<NWORDS; i++) {
    pPsram1[i] = data2;
  } // for i
  t2 = getSysTime();
  dt4 = (uint32_t)(t2 -t1);

  // copy between pseudo sram buffers
  t1 = getSysTime();
  for (i=0; i<NWORDS; i++) {
    pPsram2[i] = pPsram1[i];
  } // for i 
  t2 = getSysTime();
  dt5 = (uint32_t)(t2 -t1);

  // read from pseudo sram and check values
  for (i=0; i<NWORDS; i++) {
    if (pPsram2[i] != data2) mprintf("psramexample: pseudo sram messed up\n");
  } // for i 

  // read from pseudo sram 
  t1 = getSysTime();
  for (i=0; i<NWORDS; i++) {
    data4 = pPsram2[i];
  } // for i 
  t2    = getSysTime();
  dt6   = (uint32_t)(t2 -t1);
  
  mprintf("writing %d * 0x%x (32bit) took %7u ns or %4u ns/word or %4u Mbit/s (shared ram)\n",       NWORDS, data1, dt1, dt1/(NWORDS), (1000 * NWORDS * 32)/dt1);
  mprintf("copying %d * 0x%x (32bit) took %7u ns or %4u ns/word or %4u Mbit/s (shared -> shared)\n", NWORDS, data1, dt2, dt2/(NWORDS), (1000 * NWORDS * 32)/dt2);
  mprintf("reading %d * 0x%x (32bit) took %7u ns or %4u ns/word or %4u Mbit/s (shared ram)\n",       NWORDS, data3, dt3, dt3/(NWORDS), (1000 * NWORDS * 32)/dt3);
  mprintf("writing %d * 0x%x (32bit) took %7u ns or %4u ns/word or %4u Mbit/s (pseudo sram)\n",      NWORDS, data2, dt4, dt4/(NWORDS), (1000 * NWORDS * 32)/dt4);
  mprintf("copying %d * 0x%x (32bit) took %7u ns or %4u ns/word or %4u Mbit/s (pseudo -> pseudo)\n", NWORDS, data2, dt5, dt5/(NWORDS), (1000 * NWORDS * 32)/dt5);
  mprintf("reading %d * 0x%x (32bit) took %7u ns or %4u ns/word or %4u Mbit/s (pseudo sram)\n",      NWORDS, data4, dt6, dt6/(NWORDS), (1000 * NWORDS * 32)/dt6);

  while(1);  
} /* main */
