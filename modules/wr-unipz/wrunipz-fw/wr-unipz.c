/********************************************************************************************
 *  wr-unipz.c
 *
 *  created : 2018
 *  author  : Dietrich Beck, GSI-Darmstadt
 *  version : 25-Feb-2019
 *
 *  lm32 program for gateway between UNILAC Pulszentrale and a White Rabbit network
 *  this basically serves a Data Master for UNILAC
 *
 *  source code UNIPZ:
 *  - https://www-acc.gsi.de/viewvc/view/devacc/trunk/eqmodels/pz/common/src/pzus-dpr-def.h (relevant header file)
 *  - https://www-acc.gsi.de/viewvc/view/devacc/trunk/eqmodels/pz/pzu/src/pzu-eqms.c (source code for PZ 1..7)
 *  - https://www-acc.gsi.de/viewvc/view/devacc/trunk/eqmodels/pz/pzus/src/pzus-helper.hh (masks and definitions)
 * 
 *  'announce' events for the next cycle (received from the SuperPZ) have the following format:
 *  31..24: code (defined in pzus-dpr-def-h, lines 72ff; example: 0x10(use 'Kanal 1'), 0x00(use 'Kanal 0')
 *  23..16: virt acc
 *  15...8: 0
 *   7...1: # of PZ (** counting starts at 1(!) **)
 *  
 * -------------------------------------------------------------------------------------------
 * License Agreement for this software:
 *
 * Copyright (C) 2018  Dietrich Beck
 * GSI Helmholtzzentrum fuer Schwerionenforschung GmbH
 * Planckstrasse 1
 * D-64291 Darmstadt
 * Germany
 *
 * Contact: d.beck@gsi.de
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 3 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *  
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library. If not, see <http://www.gnu.org/licenses/>.
 *
 * For all questions and ideas contact: d.beck@gsi.de
 * Last update: 22-November-2018
 ********************************************************************************************/
#define WRUNIPZ_FW_VERSION 0x000013                                     // make this consistent with makefile

// standard includes
#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include <stdint.h>
#include "mprintf.h"
#include "mini_sdb.h"

// includes specific for bel_projects
#include "irq.h"
#include "ebm.h"
#include "aux.h"
#include "dbg.h"
#include "../../../top/gsi_scu/scu_mil.h"                               // register layout of 'MIL macro'
#include "../../../ip_cores/wr-cores/modules/wr_eca/eca_queue_regs.h"   // register layout ECA queue
#include "../../../ip_cores/wr-cores/modules/wr_eca/eca_regs.h"         // register layout ECA control
#include "../../../ip_cores/saftlib/drivers/eca_flags.h"                // register layout for ECA queue
/*                                                                      
#include "../../../ip_cores/wr-cores/modules/wr_pps_gen/pps_gen_regs.h" // useless register layout, I can't handle this wbgen stuff here
*/
// register layout for PPS GEN
#define WR_PPS_GEN_ESCR         0x1c                                    // External Sync Control Register
#define WR_PPS_GEN_ESCR_MASK    0xC                                     // bit 2: PPS valid, bit 3: timestamp valid
// register layout out for endpoint
#define WR_ENDPOINT             0x650c2d4f                              // WR-endpoint
#define WR_ENDPOINT_MACHI       0x24                                    // MAC high bytes
#define WR_ENDPOINT_MACLO       0x28                                    // MAC low bytes

// includes specific for this projects
#include <wr-unipz.h>                                                   // defs
#include <wrunipz_shared_mmap.h>                                        // autogenerated upon building firmware

// state strings
const char* dmunipz_state_text(uint32_t code) {
  switch (code) {
  case WRUNIPZ_STATE_UNKNOWN      : return "UNKNOWN   ";
  case WRUNIPZ_STATE_S0           : return "S0        ";
  case WRUNIPZ_STATE_IDLE         : return "IDLE      ";                                       
  case WRUNIPZ_STATE_CONFIGURED   : return "CONFIGURED";
  case WRUNIPZ_STATE_OPREADY      : return "opReady   ";
  case WRUNIPZ_STATE_STOPPING     : return "STOPPING  ";
  case WRUNIPZ_STATE_ERROR        : return "ERROR     ";
  case WRUNIPZ_STATE_FATAL        : return "FATAL(RIP)";
  default                         : return "undefined ";
  }
}

// stuff required for environment
extern uint32_t* _startshared[];
unsigned int     cpuId, cpuQty;
#define  SHARED  __attribute__((section(".shared")))
uint64_t SHARED  dummy = 0;

// global variables
// WB slaves
volatile uint32_t *pECAQ;               // WB address of ECA queue
volatile uint32_t *pMILPiggy;           // WB address of MIL device bus (MIL piggy)
volatile uint32_t *pPPSGen;             // WB address of PPS Gen
volatile uint32_t *pWREp;               // WB address of WR Endpoint
// shared mem
volatile uint32_t *pShared;             // pointer to begin of shared memory region
uint32_t *pSharedVersion;               // pointer to a "user defined" u32 register; here: publish version
uint32_t *pSharedSumStatus;             // pointer to a "user defined" u32 register; here: publish OR of all (actual) error bits
uint32_t *pSharedNBadStatus;            // pointer to a "user defined" u32 register; here: publish # of bad status (=error) incidents
uint32_t *pSharedNBadState;             // pointer to a "user defined" u32 register; here: publish # of bad state (=FATAL, ERROR, UNKNOWN) incidents
volatile uint32_t *pSharedCmd;          // pointer to a "user defined" u32 register; here: get command from host
uint32_t *pSharedState;                 // pointer to a "user defined" u32 register; here: publish status
volatile uint32_t *pSharedData4EB;      // pointer to a n x u32 register; here: memory region for receiving EB return values
uint32_t *pSharedMacHi;                 // pointer to a "user defined" u32 register; here: high bits of MAC
uint32_t *pSharedMacLo;                 // pointer to a "user defined" u32 register; here: low bits of MAC
uint32_t *pSharedIp;                    // pointer to a "user defined" u32 register; here: IP
uint32_t *pSharedNCycle;                // pointer to a "user defined" u32 register; here: number of UNILAC cycles
uint32_t *pSharedTCycleAvg;             // pointer to a "user defined" u32 register; here: period of UNILAC cycle [us] (average over one second)
uint32_t *pSharedNMessageHi;            // pointer to a "user defined" u32 register; here: high bits # of messages
uint32_t *pSharedNMessageLo;            // pointer to a "user defined" u32 register; here: lo bits # of messages
uint32_t *pSharedMsgFreqAvg;            // pointer to a "user defined" u32 register; here: message rate (average over one second)
uint32_t *pSharedDtMax;                 // pointer to a "user defined" u32 register; here: max diff between deadline and time of dispatching
uint32_t *pSharedDtMin;                 // pointer to a "user defined" u32 register; here: min diff between deadline and time of dispatching
uint32_t *pSharedCycJmpMax;             // pointer to a "user defined" u32 register; here: max diff between expected and actual start of UNILAC cycle
uint32_t *pSharedCycJmpMin;             // pointer to a "user defined" u32 register; here: min diff between expected and actual start of UNILAC cycle
uint32_t *pSharedNLate;                 // pointer to a "user defined" u32 register; here: # late messages
uint32_t *pSharedVaccAvg;               // pointer to a "user defined" u32 register; here: virt accs played during past second
uint32_t *pSharedPzAvg;                 // pointer to a "user defined" u32 register; here: PZs used during the past second
uint32_t *pSharedTDiagHi;               // pointer to a "user defined" u32 register; here: time when diag was cleared, high bits
uint32_t *pSharedTDiagLo;               // pointer to a "user defined" u32 register; here: time when diag was cleared, low bits
uint32_t *pSharedTS0Hi;                 // pointer to a "user defined" u32 register; here: time when FW was in S0 state, high bits
uint32_t *pSharedTS0Lo;                 // pointer to a "user defined" u32 register; here: time when FW was in S0 state, low bits
uint32_t *pSharedConfStat;              // pointer to a "user defined" u32 register; here: status of config data transaction
uint32_t *pSharedConfVacc;              // pointer to a "user defined" u32 register; here: virt acc of config data
uint32_t *pSharedConfData;              // pointer to a "user defined" u32 register; here: config data
uint32_t *pSharedConfFlag;              // pointer to a "user defined" u32 register; here: config flags
uint32_t *pSharedConfPz;                // pointer to a "user defined" u32 register; here: PZ bit field (bit N is set: transsaction for PZ N)
uint32_t *pCpuRamExternal;              // external address (seen from host bridge) of this CPU's RAM            
uint32_t *pCpuRamExternalData4EB;       // external address (seen from host bridge) of this CPU's RAM: field for EB return values

// lots of stuff to remember
uint32_t sumStatus;                     // all status infos are ORed bit-wise into sum status, sum status is then published
uint32_t nBadStatus;                    // # of bad status (=error) incidents
uint32_t nBadState;                     // # of bad state (=FATAL, ERROR, UNKNOWN) incidents
int32_t  dtMax;                         // dT max (deadline - dispatch time)
int32_t  dtMin;                         // dT min (deadline - dispatch time)
int32_t  cycJmpMax;                     // dT max (difference between actual and expected start of UNILAC cycle)
int32_t  cycJmpMin;                     // dT min (difference between actual and expected start of UNILAC cycle)
uint32_t nLate;                         // # of late messages
uint32_t vaccAvg;                       // virt accs played over the past second
uint32_t pzAvg;                         // PZs used over the past second
uint32_t nCycleAct;                     // number of cycles
uint32_t nCyclePrev;                    // previous number of cycles
uint64_t nMsgAct;                       // # of messages sent
uint64_t nMsgPrev;                      // previous number of messages
uint64_t syncPrevT;                     // timestamp of previous 50Hz sync event from SPZ
uint64_t syncPrevLen;                   // duration of previous UNILAC cycle

// flags
uint32_t flagTransactionInit;           // a transaction for uploading new event data shall be initialized
uint32_t flagTransactionSubmit;         // data uploaded during a transction shall be  commited 
uint32_t flagClearAllPZ;                // event tables of all PZs shall be cleared

// big data contains the event tables for all PZs, and for all virtual accelerators
// there are two sets of 16 virtual accelerators ('Kanal0' and 'Kanal1')
// [va0 of chn0]..[va15 of chn0][va0 of chn1]..[va15 of chn1]
dataTable bigData[WRUNIPZ_NPZ][WRUNIPZ_NVACC * WRUNIPZ_NCHN];

// info on what will be played at which PZ during actual cycles
uint32_t actVacc[WRUNIPZ_NPZ];          // vacc
uint32_t actChan[WRUNIPZ_NPZ];          // channel

// contains info on what will be played at which PZ during next cycle
uint32_t nextVacc[WRUNIPZ_NPZ];         // vacc
uint32_t nextChan[WRUNIPZ_NPZ];      // channel
uint32_t nextNochop[WRUNIPZ_NPZ];       // flag: 'no chopper'

uint32_t gid[] = {1000, 1001, 1002, 1003, 1004, 1005, 1006};              /* hackish: GIDs for PZs, to be clarified with Hanno */

// get my own MAC
uint64_t wrGetMac() 
{
  uint32_t macHi, macLo;
  uint64_t mac;

  macHi = (*(pWREp + (WR_ENDPOINT_MACHI >> 2))) & 0xffff;
  macLo = *(pWREp + (WR_ENDPOINT_MACLO >> 2));

  mac = macHi;
  mac = (mac << 32);
  mac = mac + macLo;

  return mac;
} // wrGetMac

// init EB master
uint32_t ebmInit(uint32_t msTimeout, uint64_t dstMac, uint32_t dstIp, uint32_t eb_ops) // intialize Etherbone master
{
  uint64_t timeoutT;

  // check IP
  timeoutT = getSysTime() + (uint64_t)msTimeout * (uint64_t)1000000;
  while (timeoutT < getSysTime()) {
    if (*(pEbCfg + (EBC_SRC_IP>>2)) == EBC_DEFAULT_IP) asm("nop");
    else break;
  } // while no IP via DHCP
  if (*(pEbCfg + (EBC_SRC_IP>>2)) == EBC_DEFAULT_IP) return WRUNIPZ_STATUS_NOIP;

  // init ebm
  ebm_init();
  ebm_config_if(DESTINATION, dstMac    , dstIp,                       0xebd0); 
  ebm_config_if(SOURCE,      wrGetMac(), *(pEbCfg + (EBC_SRC_IP>>2)), 0xebd0); 
  ebm_config_meta(1500, 0x0, eb_ops);
  ebm_clr();

  return WRUNIPZ_STATUS_OK;
} // ebminit

// convert UNILAC event to variables required to build a WR timing message
void data2TM(uint32_t *idLo, uint32_t *idHi, uint32_t *paramLo, uint32_t *paramHi, uint32_t *res, uint32_t *tef, uint32_t *offset, uint32_t data, uint32_t gid, uint32_t virtAcc, uint32_t noChop)  
{
  uint32_t  t;
  uint32_t  evtCode;
  uint32_t  evtData;

  // see wr-unipz.h -> 'typedef struct dataTable' on definition of bits in data
  t        = (uint32_t)((data >> 16) & 0xffff);      // get time relative to begining of UNILAC cycle [us]
  evtCode  = (uint32_t)( data        & 0x00ff);      // get event number
  evtData  = (uint32_t)((data >> 12) & 0x000f);      // get event data
  evtData  = evtData | ((noChop & 0x1) << 1);        // set 'no chopper' bit
  

  *idHi     = (uint32_t)(                            // EventID
                          0x1     << 28      |       // FID = 1
                         (gid     << 16)     |       // GID
                         (evtCode <<  4)     |       // EVTNO
                          0x0                        // flags
                        );
  *idLo     = (uint32_t)(
                         (virtAcc << 20)     |       // SID
                         (0x0     <<  6)     |       // BPID
                         (0x0     <<  5)     |       // reserved
                         (0x0     <<  4)     |       // reqNoBeam
                          0x0                        // virtAcc only for DM-UNIPZ gateway
                        );
  *paramLo  = evtData;                               // parameter field   /* chk with hanno */
  *paramHi  = 0x0;                                   
  *res      = 0x0;                                   // reserved
  *tef      = 0x0;                                   // timing extension field
  *offset   = t * 1000;                              // convert offset -> ns
} // data2TM

// write a timing message to the WR network via the EB master
uint64_t ebmWriteTM(uint32_t evtData, uint64_t tStart, uint32_t pz, uint32_t virtAcc, uint32_t flagNochop)
{
  uint64_t deadline;
  uint32_t res, tef;
  uint32_t deadlineLo, deadlineHi, offset;
  uint32_t idLo, idHi;
  uint32_t paramLo, paramHi;
  int32_t  tDiff;                             // diff between deadline and dispatch timed

  // set high bits for EB master
  ebm_hi(WRUNIPZ_ECA_ADDRESS);
  
  // convert data
  data2TM(&idLo, &idHi, &paramLo, &paramHi, &res, &tef, &offset, evtData, gid[pz], virtAcc, flagNochop);  //convert data
  
  // calc deadline
  deadline   = tStart + (uint64_t)offset + (uint64_t)WRUNIPZ_MILCALIBOFFSET; 
  deadlineHi = (uint32_t)((deadline >> 32) & 0xffffffff);
  deadlineLo = (uint32_t)(deadline & 0xffffffff);
  
  // pack timing message
  atomic_on();                                  
  ebm_op(WRUNIPZ_ECA_ADDRESS, idHi,       EBM_WRITE);             
  ebm_op(WRUNIPZ_ECA_ADDRESS, idLo,       EBM_WRITE);             
  ebm_op(WRUNIPZ_ECA_ADDRESS, paramHi,    EBM_WRITE);
  ebm_op(WRUNIPZ_ECA_ADDRESS, paramLo,    EBM_WRITE);
  ebm_op(WRUNIPZ_ECA_ADDRESS, tef,        EBM_WRITE);
  ebm_op(WRUNIPZ_ECA_ADDRESS, res,        EBM_WRITE);
  ebm_op(WRUNIPZ_ECA_ADDRESS, deadlineHi, EBM_WRITE);
  ebm_op(WRUNIPZ_ECA_ADDRESS, deadlineLo, EBM_WRITE);
  atomic_off();
  
  // send timing message
  ebm_flush();
  
  // diag and status
  tDiff = deadline - getSysTime();
  if (tDiff < 0    ) nLate++;
  if (tDiff < dtMin) dtMin = tDiff;
  if (tDiff > dtMax) dtMax = tDiff;
  
  vaccAvg = vaccAvg | (1 << virtAcc);
  pzAvg   = pzAvg   | (1 << pz);
  nMsgAct++;

  return deadline;
} // ebmWriteTm

// plays virtual accelerators for all 'Pulszentralen'
uint32_t pzRunVacc(dataTable evts, uint64_t tStart, uint32_t pz, uint32_t virtAcc, uint32_t isPrep)
{
  int      i;
  uint64_t offset;

  // pack Ethernet frame with messages
  for (i=0; i<WRUNIPZ_NEVT; i++) {                     // loop over all data fields
    if ((evts.validFlags >> i) & 0x1) {                // data is valid?
      if ((evts.evtFlags >> i) & 0x1) {                // data is an event?
        if (((evts.prepFlags >> i) & 0x1) == isPrep) { // data matches 'isPrep condition'
          offset = ebmWriteTM(evts.data[i], tStart, pz, virtAcc, nextNochop[pz]);
        } // if 'isPrep'
      } // is event
    } // is valid
  } // for i

  return WRUNIPZ_STATUS_OK;
} // pzRunVacc

// get length of vacc
uint32_t getVaccLen(dataTable evts)
{
  int      i;
  uint32_t usOffset;
  uint32_t tmp;
  

  usOffset = 0;
  
  for (i=0; i<WRUNIPZ_NEVT; i++) {
    if ((evts.validFlags >> i) & 0x1) {
      tmp = (uint32_t)((evts.data[i] >> 16) & 0xffff);
      if (tmp > usOffset) usOffset = tmp;
    } // if validFlags
  } // for i

  return usOffset;
} //getVaccLen

//check status of White Rabbit (link up, tracking)
uint32_t wrCheckSyncState() 
{
  uint32_t syncState;

  syncState =  *(pPPSGen + (WR_PPS_GEN_ESCR >> 2));                         // read status
  syncState = syncState & WR_PPS_GEN_ESCR_MASK;                             // apply mask

  if ((syncState == WR_PPS_GEN_ESCR_MASK)) return WRUNIPZ_STATUS_OK;        // check if all relevant bits are set
  else                                     return WRUNIPZ_STATUS_WRBADSYNC;
} //wrCheckStatus

// typical init for lm32
void init() 
{
  discoverPeriphery();        // mini-sdb ...
  uart_init_hw();             // needed by WR console   
  cpuId = getCpuIdx();

  timer_init(1);              // needed by usleep_init() 
  usleep_init();              // needed by scu_mil.c

  // set MSI IRQ handler
  isr_table_clr();
  //irq_set_mask(0x01);
  irq_disable();
} // init

// determine address and clear shared mem
void initSharedMem() 
{
  uint32_t idx;
  uint32_t *pSharedTemp;
  int      i; 
  const uint32_t c_Max_Rams = 10;
  sdb_location found_sdb[c_Max_Rams];
  sdb_location found_clu;
  
  // get pointer to shared memory
  pShared           = (uint32_t *)_startshared;

  // get address to data
  pSharedVersion          = (uint32_t *)(pShared + (WRUNIPZ_SHARED_VERSION >> 2));
  pSharedSumStatus        = (uint32_t *)(pShared + (WRUNIPZ_SHARED_SUMSTATUS >> 2));
  pSharedCmd              = (uint32_t *)(pShared + (WRUNIPZ_SHARED_CMD >> 2));
  pSharedState            = (uint32_t *)(pShared + (WRUNIPZ_SHARED_STATE >> 2));
  pSharedData4EB          = (uint32_t *)(pShared + (WRUNIPZ_SHARED_DATA_4EB >> 2));
  pSharedNBadStatus       = (uint32_t *)(pShared + (WRUNIPZ_SHARED_NBADSTATUS >> 2));
  pSharedNBadState        = (uint32_t *)(pShared + (WRUNIPZ_SHARED_NBADSTATE >> 2));
  pSharedMacHi            = (uint32_t *)(pShared + (WRUNIPZ_SHARED_MACHI >> 2));
  pSharedMacLo            = (uint32_t *)(pShared + (WRUNIPZ_SHARED_MACLO >> 2));
  pSharedIp               = (uint32_t *)(pShared + (WRUNIPZ_SHARED_IP >> 2));
  pSharedNCycle           = (uint32_t *)(pShared + (WRUNIPZ_SHARED_NCYCLE >> 2));  
  pSharedTCycleAvg        = (uint32_t *)(pShared + (WRUNIPZ_SHARED_TCYCLEAVG >> 2));
  pSharedNMessageHi       = (uint32_t *)(pShared + (WRUNIPZ_SHARED_NMESSAGEHI >> 2));
  pSharedNMessageLo       = (uint32_t *)(pShared + (WRUNIPZ_SHARED_NMESSAGELO >> 2));
  pSharedMsgFreqAvg       = (uint32_t *)(pShared + (WRUNIPZ_SHARED_MSGFREQAVG >> 2));
  pSharedDtMax            = (uint32_t *)(pShared + (WRUNIPZ_SHARED_DTMAX >> 2));
  pSharedDtMin            = (uint32_t *)(pShared + (WRUNIPZ_SHARED_DTMIN >> 2));
  pSharedCycJmpMax        = (uint32_t *)(pShared + (WRUNIPZ_SHARED_CYCJMPMAX >> 2));
  pSharedCycJmpMin        = (uint32_t *)(pShared + (WRUNIPZ_SHARED_CYCJMPMIN >> 2));
  pSharedNLate            = (uint32_t *)(pShared + (WRUNIPZ_SHARED_NLATE >> 2));
  pSharedVaccAvg          = (uint32_t *)(pShared + (WRUNIPZ_SHARED_VACCAVG >> 2));
  pSharedPzAvg            = (uint32_t *)(pShared + (WRUNIPZ_SHARED_PZAVG >> 2));
  pSharedTDiagHi          = (uint32_t *)(pShared + (WRUNIPZ_SHARED_TDIAGHI >> 2));
  pSharedTDiagLo          = (uint32_t *)(pShared + (WRUNIPZ_SHARED_TDIAGLO >> 2));
  pSharedTS0Hi            = (uint32_t *)(pShared + (WRUNIPZ_SHARED_TS0HI >> 2));
  pSharedTS0Lo            = (uint32_t *)(pShared + (WRUNIPZ_SHARED_TS0LO >> 2));
  pSharedConfStat         = (uint32_t *)(pShared + (WRUNIPZ_SHARED_CONF_STAT >> 2));
  pSharedConfVacc         = (uint32_t *)(pShared + (WRUNIPZ_SHARED_CONF_VACC >> 2));
  pSharedConfData         = (uint32_t *)(pShared + (WRUNIPZ_SHARED_CONF_DATA >> 2));
  pSharedConfFlag         = (uint32_t *)(pShared + (WRUNIPZ_SHARED_CONF_FLAG >> 2));
  pSharedConfPz           = (uint32_t *)(pShared + (WRUNIPZ_SHARED_CONF_PZ >> 2));
  
  // find address of CPU from external perspective
  idx = 0;
  find_device_multi(&found_clu, &idx, 1, GSI, LM32_CB_CLUSTER);	
  idx = 0;
  find_device_multi_in_subtree(&found_clu, &found_sdb[0], &idx, c_Max_Rams, GSI, LM32_RAM_USER);
  if(idx >= cpuId) {
    pCpuRamExternal           = (uint32_t *)(getSdbAdr(&found_sdb[cpuId]) & 0x7FFFFFFF); // CPU sees the 'world' under 0x8..., remove that bit to get host bridge perspective
    pCpuRamExternalData4EB    = (uint32_t *)(pCpuRamExternal + ((WRUNIPZ_SHARED_DATA_4EB + SHARED_OFFS) >> 2));
  }

  DBPRINT2("wr-unipz: CPU RAM External 0x%8x, begin shared 0x%08x\n", pCpuRamExternal, SHARED_OFFS);

  // clear shared mem
  i = 0;
  pSharedTemp          = (uint32_t *)(pShared + (WRUNIPZ_SHARED_BEGIN >> 2 ));
  while (pSharedTemp < (uint32_t *)(pShared + (WRUNIPZ_SHARED_END >> 2 ))) {
    *pSharedTemp = 0x0;
    pSharedTemp++;
    i++;
  } // while pSharedTemp
  DBPRINT2("wr-unipz: used size of shared mem is %d words (uint32_t), begin %x, end %x\n", i, pShared, pSharedTemp-1);
  
  // set initial values;
  *pSharedVersion      = WRUNIPZ_FW_VERSION; // of all the shared variabes, only VERSION is a constant. Set it now!
  *pSharedNBadStatus   = 0;
  *pSharedNBadState    = 0;
  *pSharedConfStat     = WRUNIPZ_CONFSTAT_IDLE;
} // initSharedMem 

//find WB address of MIL Piggy
uint32_t findMILPiggy() 
{
  pMILPiggy = 0x0;
  
  // get Wishbone address for MIL Piggy
  pMILPiggy = find_device_adr(GSI, SCU_MIL);

  if (!pMILPiggy) {DBPRINT1("wr-unipz: can't find MIL piggy\n"); return WRUNIPZ_STATUS_ERROR;}
  else                                                           return WRUNIPZ_STATUS_OK;
} // findMILPiggy

//find WB address of WR PPS Gen
uint32_t findPPSGen() 
{
  pPPSGen = 0x0;
  
  // get Wishbone address for PPS Gen
  pPPSGen = find_device_adr(CERN, WR_PPS_GEN);

  if (!pPPSGen) {DBPRINT1("wr-unipz: can't find WR PPS Gen\n"); return WRUNIPZ_STATUS_ERROR;}
  else                                                          return WRUNIPZ_STATUS_OK;
} // findPPSGen

//find WB address of WR Endpoint
uint32_t findWREp() 
{
  pWREp = 0x0;
  
  // get Wishbone address for WR Endpoint
  pWREp = find_device_adr(CERN, WR_ENDPOINT);

  if (!pWREp) {DBPRINT1("wr-unipz: can't find WR Endpoint\n"); return WRUNIPZ_STATUS_ERROR;}
  else                                                         return WRUNIPZ_STATUS_OK;
} // findWREp

// find WB address of ECA channel for LM32
uint32_t findECAQueue() 
{
#define ECAQMAX           4     // max number of ECA channels in the system
#define ECACHANNELFORLM32 2     // this is a hack! suggest implementing finding via sdb-record and info

  // stuff below needed to get WB address of ECA queue
  sdb_location ECAQ_base[ECAQMAX];
  uint32_t ECAQidx = 0;         
  uint32_t *tmp;                
  int i;

  // get Wishbone address of ECA queue 
  // get list of ECA queues
  find_device_multi(ECAQ_base, &ECAQidx, ECAQMAX, ECA_QUEUE_SDB_VENDOR_ID, ECA_QUEUE_SDB_DEVICE_ID);
  pECAQ = 0x0;

  // find ECA queue connected to ECA chanel for LM32
  for (i=0; i < ECAQidx; i++) {
    tmp = (uint32_t *)(getSdbAdr(&ECAQ_base[i]));  
    if ( *(tmp + (ECA_QUEUE_QUEUE_ID_GET >> 2)) == ECACHANNELFORLM32) pECAQ = tmp;
  }

  if (!pECAQ) {DBPRINT1("wr-unipz: can't find ECA queue\n"); return WRUNIPZ_STATUS_ERROR;}
  else                                                       return WRUNIPZ_STATUS_OK;
} // findECAQueue

// 1. query ECA for actions, 2. trigger activity
uint32_t wait4ECAEvent(uint32_t msTimeout, uint64_t *deadline, uint32_t *isLate)
{
  uint32_t *pECAFlag;           // address of ECA flag
  uint32_t evtIdHigh;           // high 32bit of eventID   
  uint32_t evtIdLow;            // low 32bit of eventID    
  uint32_t evtDeadlHigh;        // high 32bit of deadline  
  uint32_t evtDeadlLow;         // low 32bit of deadline   
  uint32_t evtParamHigh;        // high 32 bit of parameter field
  uint32_t evtParamLow ;        // low 32 bit of parameter field
  uint32_t evtTef;              // 32 bit TEF field
  uint32_t actTag;              // tag of action           
  uint32_t nextAction;          // describes what to do next
  uint64_t timeoutT;            // when to time out

  pECAFlag    = (uint32_t *)(pECAQ + (ECA_QUEUE_FLAGS_GET >> 2));   // address of ECA flag

  timeoutT    = getSysTime() + (uint64_t)msTimeout * (uint64_t)1000000 + (uint64_t)1000; 
  
  while (getSysTime() < timeoutT) {
    if (*pECAFlag & (0x0001 << ECA_VALID)) {                        // if ECA data is valid

      // read data
      evtIdHigh    = *(pECAQ + (ECA_QUEUE_EVENT_ID_HI_GET >> 2));
      evtIdLow     = *(pECAQ + (ECA_QUEUE_EVENT_ID_LO_GET >> 2));
      evtDeadlHigh = *(pECAQ + (ECA_QUEUE_DEADLINE_HI_GET >> 2));
      evtDeadlLow  = *(pECAQ + (ECA_QUEUE_DEADLINE_LO_GET >> 2));
      actTag       = *(pECAQ + (ECA_QUEUE_TAG_GET >> 2));
      evtParamHigh = *(pECAQ + (ECA_QUEUE_PARAM_HI_GET >> 2));
      evtParamLow  = *(pECAQ + (ECA_QUEUE_PARAM_LO_GET >> 2));
      evtTef       = *(pECAQ + (ECA_QUEUE_TEF_GET >> 2));
      *isLate      = *pECAFlag & (0x0001 << ECA_LATE);

      *deadline    = ((uint64_t)evtDeadlHigh << 32) + (uint64_t)evtDeadlLow;
      
      // pop action from channel
      *(pECAQ + (ECA_QUEUE_POP_OWR >> 2)) = 0x1;

      // here: do s.th. according to tag
      switch (actTag) 
        {
        case WRUNIPZ_ECADO_MIL :
          nextAction = WRUNIPZ_ECADO_MIL;
          break;
        default: 
          nextAction = WRUNIPZ_ECADO_UNKOWN;
          break;
        } // switch

      return nextAction;

    } // if data is valid
  } // while not timed out

  return  WRUNIPZ_ECADO_TIMEOUT;
} // wait for ECA event

// init stuff for handling commands, trivial for now, will be extended
void initCmds()
{
  //  initalize command value: 0x0 means 'no command'
  *pSharedCmd     = 0x0;
} // initCmds

// configure SoC to receive events via MIL bus
uint32_t configMILEvent()
{
  uint32_t i;

  // initialize status and command register with initial values; disable event filtering; clear filter RAM
  if (writeCtrlStatRegEvtMil(pMILPiggy, MIL_CTRL_STAT_ENDECODER_FPGA | MIL_CTRL_STAT_INTR_DEB_ON) != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR; //chk sure we go for status error?

  // clean up 
  if (disableLemoEvtMil(pMILPiggy, 1) != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR;
  if (disableLemoEvtMil(pMILPiggy, 2) != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR;
  if (disableFilterEvtMil(pMILPiggy)  != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR; 
  if (clearFilterEvtMil(pMILPiggy)    != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR; 

  for (i=0; i < (0xf+1); i++) {
    // set filter for all possible virtual accelerators; set filter and LEMO for 50 Hz sync
    if (setFilterEvtMil(pMILPiggy, WRUNIPZ_EVT_50HZ_SYNCH, i, MIL_FILTER_EV_TO_FIFO | MIL_FILTER_EV_PULS1_S) != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR;
    if (setFilterEvtMil(pMILPiggy, WRUNIPZ_EVT_PZ1       , i, MIL_FILTER_EV_TO_FIFO                        ) != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR;
    if (setFilterEvtMil(pMILPiggy, WRUNIPZ_EVT_PZ2       , i, MIL_FILTER_EV_TO_FIFO                        ) != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR;
    if (setFilterEvtMil(pMILPiggy, WRUNIPZ_EVT_PZ3       , i, MIL_FILTER_EV_TO_FIFO                        ) != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR;
    if (setFilterEvtMil(pMILPiggy, WRUNIPZ_EVT_PZ4       , i, MIL_FILTER_EV_TO_FIFO                        ) != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR;
    if (setFilterEvtMil(pMILPiggy, WRUNIPZ_EVT_PZ5       , i, MIL_FILTER_EV_TO_FIFO                        ) != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR;
    if (setFilterEvtMil(pMILPiggy, WRUNIPZ_EVT_PZ6       , i, MIL_FILTER_EV_TO_FIFO                        ) != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR;
    if (setFilterEvtMil(pMILPiggy, WRUNIPZ_EVT_PZ7       , i, MIL_FILTER_EV_TO_FIFO                        ) != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR;
  }

  // configure LEMO1 for pulse generation
  if (configLemoPulseEvtMil(pMILPiggy, 1) != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR;

  return WRUNIPZ_STATUS_OK;
} // configMILEvent

// wait for MIL event or timeout
 uint32_t wait4MILEvent(uint32_t *evtData, uint32_t *evtCode, uint32_t *virtAcc, uint32_t msTimeout) 
{
  uint32_t evtRec;             // one MIL event
  uint32_t evtCodeRec;         // "event number"
  uint32_t evtDataRec;         // "event data"
  uint32_t virtAccRec;         // "virt Acc"
  uint64_t timeoutT;           // when to time out
  int      valid;              // evt is valid

  timeoutT    = getSysTime() + (uint64_t)msTimeout * (uint64_t)1000000;
  *virtAcc    = 0xffff;           
  *evtData    = 0xffff;
  *evtCode    = 0xffff;
  valid       = 0;
  
  while(getSysTime() < timeoutT) {              // while not timed out...
    while (fifoNotemptyEvtMil(pMILPiggy)) {     // while fifo contains data
      popFifoEvtMil(pMILPiggy, &evtRec);    
      evtCodeRec  = evtRec & 0x000000ff;        // extract event code
      virtAccRec  = (evtRec >> 8)  & 0x0f;      // extract virtual accelerator
      evtDataRec  = (evtRec >> 12) & 0x0f;      // extract event data

      //mprintf("data %d, code %d, vA %d\n", evtDataRec, evtCodeRec, virtAccTmp);

      switch (evtCodeRec) {
      case WRUNIPZ_EVT_PZ1 ... WRUNIPZ_EVT_PZ7 : valid = 1; break;
      case WRUNIPZ_EVT_SYNCH_DATA              : valid = 1; break;
      case WRUNIPZ_EVT_50HZ_SYNCH              : valid = 1; break;
      default                                  : break;
      } // switch event code

      if (valid) {
        *evtData     = evtDataRec;
        *evtCode     = evtCodeRec;
        *virtAcc     = virtAccRec;
        return WRUNIPZ_STATUS_OK;
      } // if valid;
    } // while fifo contains data
    asm("nop");                                 // wait a bit...
  } // while not timed out

  return WRUNIPZ_STATUS_TIMEDOUT;  
} //wait4MILEvent

//for debugging with scope
void pulseLemo2()
{
  uint32_t i;

  setLemoOutputEvtMil(pMILPiggy, 2, 1);
  for (i=0; i< 10 * WRUNIPZ_US_ASMNOP; i++) asm("nop");
  setLemoOutputEvtMil(pMILPiggy, 2, 0);
} // pulseLemo2

// clears all statistics
void clearDiag() 
{
  uint64_t now;
  
  dtMax          = 0x80000000;
  dtMin          = 0x7fffffff;
  cycJmpMax      = 0x80000000;
  cycJmpMin      = 0x7fffffff;
  nLate          = 0;
  nCycleAct      = 0;
  nCyclePrev     = 0;
  nMsgAct        = 0;
  nMsgPrev       = 0;
  sumStatus      = 0;
  nBadStatus     = 0;

  now = getSysTime();
  *pSharedTDiagHi = (uint32_t)(now >> 32);
  *pSharedTDiagLo = (uint32_t)now & 0xffffffff;

} // clearDiag

// initializes transaction for config data
uint32_t configTransactInit()
{
  int i,j;

  uint64_t t1, t2;
  uint32_t dt;

  t1 = getSysTime();
  
  if (*pSharedConfStat != WRUNIPZ_CONFSTAT_IDLE) return WRUNIPZ_STATUS_TRANSACTION;

  *pSharedConfPz    = 0;
  *pSharedConfVacc  = 0;
  for (i=0; i < (WRUNIPZ_NCONFFLAG); i++) *(pSharedConfFlag   + i) = 0;
  for (i=0; i < (WRUNIPZ_NCONFDATA); i++) *(pSharedConfData   + i) = 0;

  DBPRINT2("wr-unipz: request completed\n");
    
  *pSharedConfStat = WRUNIPZ_CONFSTAT_INIT;

  t2 = getSysTime();
  dt = (uint32_t)(t2-t1);
  //mprintf("wr-unipz: confTransInit dt %u\n", dt);

  return WRUNIPZ_STATUS_OK;
} // configTransactInit

// submit transferred config data
uint32_t configTransactSubmit() 
{
  int      i,j,k;
  int      vacc;
  uint32_t pzFlag;

  if (*pSharedConfStat != WRUNIPZ_CONFSTAT_INIT) return WRUNIPZ_STATUS_TRANSACTION;

  // get vacc and submit flags
  vacc    = *pSharedConfVacc;
  pzFlag  = *pSharedConfPz;

  for (i=0; i < WRUNIPZ_NPZ; i++) {        // for all Pulszentralen
    for (j=0; j < WRUNIPZ_NCHN; j++) {     // for all channels
      if (pzFlag & (1 << i)) {             // check, if Pulszentrale (defined by "i") shall be submitted
        // flags
        bigData[i][j * WRUNIPZ_NVACC + vacc].validFlags = *(pSharedConfFlag + j * WRUNIPZ_NFLAG + i * WRUNIPZ_NPZ * WRUNIPZ_NCHN + 0);
        bigData[i][j * WRUNIPZ_NVACC + vacc].prepFlags  = *(pSharedConfFlag + j * WRUNIPZ_NFLAG + i * WRUNIPZ_NPZ * WRUNIPZ_NCHN + 1);
        bigData[i][j * WRUNIPZ_NVACC + vacc].evtFlags   = *(pSharedConfFlag + j * WRUNIPZ_NFLAG + i * WRUNIPZ_NPZ * WRUNIPZ_NCHN + 2);

        // data
        for (k=0; k < WRUNIPZ_NEVT; k++) 
          bigData[i][j * WRUNIPZ_NVACC + vacc].data[k]  = *(pSharedConfData + j * WRUNIPZ_NEVT  + i * WRUNIPZ_NEVT * WRUNIPZ_NCHN + k);
      } // if submit flag
    } // for j
  } // for i
  /* end hack */

  DBPRINT2("wr-unipz: submit completed\n");
  
  /* *pSharedConfDataStat = WRUNIPZ_CONFSTAT_REQ | WRUNIPZ_CONFSTAT_SUBMIT; commented: this shall be used once code above is triggered by event */
  *pSharedConfStat = WRUNIPZ_CONFSTAT_IDLE;

  return WRUNIPZ_STATUS_OK;
} // configTransactSubmit

// clears data of all PZs
void clearAllPZ()
{
  int i,j,k;

  for (i=0; i < WRUNIPZ_NPZ; i++)
    for (j=0; j < (WRUNIPZ_NVACC * WRUNIPZ_NCHN); j++) {
      bigData[i][j].validFlags = 0x0;
      bigData[i][j].prepFlags  = 0x0;
      bigData[i][j].evtFlags   = 0x0;
      for (k=0; k < WRUNIPZ_NEVT; k++) bigData[i][j].data[k] = 0x0;
    } // for j
} // clear PZ

// do action S0 state
uint32_t doActionS0()
{
  uint32_t status = WRUNIPZ_STATUS_OK;
  uint64_t now;

  if (findECAQueue() != WRUNIPZ_STATUS_OK) status = WRUNIPZ_STATUS_ERROR; 
  if (findMILPiggy() != WRUNIPZ_STATUS_OK) status = WRUNIPZ_STATUS_ERROR;
  if (findPPSGen()   != WRUNIPZ_STATUS_OK) status = WRUNIPZ_STATUS_ERROR;
  if (findWREp()     != WRUNIPZ_STATUS_OK) status = WRUNIPZ_STATUS_ERROR;

  nBadState     = 0;
  now           = getSysTime();
  *pSharedTS0Hi = (uint32_t)(now >> 32);
  *pSharedTS0Lo = (uint32_t)now & 0xffffffff;
  
  initCmds();                    

  return status;
} // doActionS0

// entry action configured state
uint32_t entryActionConfigured()
{
  uint32_t status = WRUNIPZ_STATUS_OK;
  uint64_t mac;
  uint32_t ip;

  // configure EB master (SRC and DST MAC/IP are set from host)
  //  ebmInit(100, 0xffffffffffff, 0xffffffff, EBM_NOREPLY);
  if ((status = ebmInit(2000, 0xffffffffffff, 0xffffffff, EBM_NOREPLY)) != WRUNIPZ_STATUS_OK) {
    DBPRINT1("wr-unipz: ERROR - init of EB master failed! %d\n", status);
    return status;
  } 

  // get and publish NIC data
  mac = wrGetMac();
  *pSharedMacHi = (uint32_t)(mac >> 32) & 0xffff;
  *pSharedMacLo = (uint32_t)mac         & 0xffffffff;

  ip  = *(pEbCfg + (EBC_SRC_IP>>2));
  *pSharedIp    = ip;

  // reset MIL piggy and wait
  if ((status = resetPiggyDevMil(pMILPiggy))  != MIL_STAT_OK) {
    DBPRINT1("wr-unipz: ERROR - can't reset MIL Piggy\n");
    return WRUNIPZ_STATUS_MIL;
  } 
  
  // configure MIL piggy for timing events for all 16 virtual accelerators
  if ((status = configMILEvent()) != WRUNIPZ_STATUS_OK) {
    DBPRINT1("wr-unipz: ERROR - failed to configure MIL piggy for receiving timing events! %d\n", status);
    return status;
  } 

  DBPRINT1("wr-unipz: MIL piggy configured for receving events (eventbus)\n");

  configLemoOutputEvtMil(pMILPiggy, 2);    // used to see a blinking LED (and optionally connect a scope) for debugging
  
  *pSharedConfStat = WRUNIPZ_CONFSTAT_IDLE; /* chk */

  return status;
} // entryActionConfigured

// entry action state 'op ready'
uint32_t entryActionOperation()
{
  int      i;
  uint64_t tDummy;
  uint32_t flagDummy;
  
  clearDiag();                                               // clear diagnostics
  clearAllPZ();                                              // clear all event tables

  flagClearAllPZ        = 0;
  flagTransactionInit   = 0;
  flagTransactionSubmit = 0;
  for (i=0; i < WRUNIPZ_NPZ; i++) nextVacc[i] = 0xffffffff;  // 0xffffffff: no virt acc
  for (i=0; i < WRUNIPZ_NPZ; i++) actVacc[i]  = 0xffffffff;  // 0xffffffff: no virt acc
  
  enableFilterEvtMil(pMILPiggy);                             // enable MIL event filter
  clearFifoEvtMil(pMILPiggy);                                // clear MIL event FIFO

  // flush ECA queue for lm32
  i = 0;
  while (wait4ECAEvent(1, &tDummy, &flagDummy) !=  WRUNIPZ_ECADO_TIMEOUT) {i++;}
  DBPRINT1("wr-unipz: ECA queue flushed - removed %d pending entries from ECA queue\n", i);

  return WRUNIPZ_STATUS_OK;
} // entryActionOperation

// exit action state 'op ready'
uint32_t exitActionOperation(){
  if (disableFilterEvtMil(pMILPiggy) != MIL_STAT_OK) return WRUNIPZ_STATUS_ERROR; 
  
  return WRUNIPZ_STATUS_OK;
} // exitActionOperation

uint32_t exitActionError()
{
  return WRUNIPZ_STATUS_OK;
} // exitActionError

// command handler
void cmdHandler(uint32_t *reqState) // handle commands from the outside world
{
  uint32_t cmd;

  cmd = *pSharedCmd;
  // check, if the command is valid and request state change
  if (cmd) {
    switch (cmd) {
    case WRUNIPZ_CMD_CONFIGURE :
      *reqState =  WRUNIPZ_STATE_CONFIGURED;
      DBPRINT3("wr-unipz: received cmd %d\n", cmd);
      break;
    case WRUNIPZ_CMD_STARTOP :
      *reqState = WRUNIPZ_STATE_OPREADY;
      DBPRINT3("wr-unipz: received cmd %d\n", cmd);
      break;
    case WRUNIPZ_CMD_STOPOP :
      *reqState = WRUNIPZ_STATE_STOPPING;
      DBPRINT3("wr-unipz: received cmd %d\n", cmd);
      break;
    case WRUNIPZ_CMD_IDLE :
      *reqState = WRUNIPZ_STATE_IDLE;
      DBPRINT3("wr-unipz: received cmd %d\n", cmd);
      break;
    case WRUNIPZ_CMD_RECOVER :
      *reqState = WRUNIPZ_STATE_IDLE;
      DBPRINT3("wr-unipz: received cmd %d\n", cmd);
      break;
    case WRUNIPZ_CMD_CLEARDIAG :
      DBPRINT3("wr-unipz: received cmd %d\n", cmd);
      clearDiag();
      break;
    case WRUNIPZ_CMD_CONFINIT :
      DBPRINT3("wr-unipz: received cmd %d\n", cmd);
      flagTransactionInit = 1;
      break;
    case WRUNIPZ_CMD_CONFSUBMIT :
      DBPRINT3("wr-unipz: received cmd %d\n", cmd);
      if (configTransactSubmit() != WRUNIPZ_STATUS_OK) DBPRINT1("wr-unipz: submission of config data failed\n");
      // takes about 51us, possibly just set a flag here and call routine after WRUNIPZ_EVT_50HZ_SYNCH
      break;
    case WRUNIPZ_CMD_CONFKILL :
      DBPRINT3("wr-unipz: received cmd %d\n", cmd);
      *pSharedConfStat = WRUNIPZ_CONFSTAT_IDLE;
      break;     
    case WRUNIPZ_CMD_CONFCLEAR :
      DBPRINT3("wr-unipz: received cmd %d\n", cmd);
      flagClearAllPZ = 1;
      break;
    default:
      DBPRINT3("wr-unipz: received unknown command '0x%08x'\n", cmd);
    } // switch 
    *pSharedCmd = 0x0; // reset cmd value in shared memory 
  } // if command 
} // cmdHandler

// state machine
uint32_t changeState(uint32_t *actState, uint32_t *reqState, uint32_t actStatus)   //state machine; see wr-unipz.h for possible states and transitions
{
  uint32_t statusTransition= WRUNIPZ_STATUS_OK;
  uint32_t status;
  uint32_t nextState;                   

  // if something severe happened, perform implicitely allowed transition to ERROR or FATAL states
  // else                        , handle explicitcely allowed transitions

  if ((*reqState == WRUNIPZ_STATE_ERROR) || (*reqState == WRUNIPZ_STATE_FATAL)) {statusTransition = actStatus; nextState = *reqState;}
  else {
    nextState = *actState;                       // per default: remain in actual state without exit or entry action
    switch (*actState) {                         // check for allowed transitions: 1. determine next state, 2. perform exit or entry actions if required
    case WRUNIPZ_STATE_S0:
      if      (*reqState == WRUNIPZ_STATE_IDLE)       {                                            nextState = *reqState;}      
      break;
    case WRUNIPZ_STATE_IDLE:
      if      (*reqState == WRUNIPZ_STATE_CONFIGURED)  {statusTransition = entryActionConfigured(); nextState = *reqState;}
      break;
    case WRUNIPZ_STATE_CONFIGURED:
      if      (*reqState == WRUNIPZ_STATE_IDLE)       {                                            nextState = *reqState;}
      else if (*reqState == WRUNIPZ_STATE_CONFIGURED) {statusTransition = entryActionConfigured(); nextState = *reqState;}
      else if (*reqState == WRUNIPZ_STATE_OPREADY)    {statusTransition = entryActionOperation();  nextState = *reqState;}
      break;
    case WRUNIPZ_STATE_OPREADY:
      if      (*reqState == WRUNIPZ_STATE_STOPPING)   {statusTransition = exitActionOperation();   nextState = *reqState;}
      break;
    case WRUNIPZ_STATE_STOPPING:
      nextState = WRUNIPZ_STATE_CONFIGURED;      //automatic transition but without entryActionConfigured
    case WRUNIPZ_STATE_ERROR:
      if      (*reqState == WRUNIPZ_STATE_IDLE)       {statusTransition = exitActionError();       nextState = *reqState;}
      break;
    default: 
      nextState = WRUNIPZ_STATE_S0;
    } // switch actState
  }  // else something severe happened
  
  // if the transition failed, transit to error state (except we are already in FATAL state)
  if ((statusTransition != WRUNIPZ_STATUS_OK) && (nextState != WRUNIPZ_STATE_FATAL)) nextState = WRUNIPZ_STATE_ERROR;

  // if the state changes
  if (*actState != nextState) {                   
    mprintf("wr-unipz: changed to state %d\n", nextState);
    *actState = nextState;                      
    status = statusTransition;
  } // if state change
  else  status = actStatus;

  *reqState = WRUNIPZ_STATE_UNKNOWN;             // reset requested state (= no change state requested)  

  return status;
} //changeState

// do action state 'op ready' - main code of this FW
uint32_t doActionOperation(uint32_t *nCycle,                  // total number of UNILAC cycle since FW start
                           uint32_t actStatus)                // actual status of firmware
{
  uint32_t status;                                            // status returned by routines
  uint32_t flagIsLate;                                        // flag indicating that we received a 'late' event from ECA
  uint32_t ecaAction;                                         // action triggered by event received from ECA
  uint64_t deadline;                                          // deadline of event received via ECA
  uint64_t tMIL;                                              // time when MIL event was received
  uint64_t tDummy;                                            // dummy timestamp
  uint32_t evtData;                                           // MIL event: data
  uint32_t evtCode;                                           // MIL event: code
  uint32_t virtAcc;                                           // MIL event: virtAcc
  uint32_t milStatus;                                         // status for receiving of MIL events
  uint32_t nLateLocal;                                        // remember actual counter
  uint32_t isPrepFlag;                                        // flag 'isPrep': prep-events are sent immediately, non-prep-events are sent at 50 Hz trigger
  int      ipz;                                               // index of PZ, helper variable
  int      i,j;
  dataTable servNow;                                          // used to send a service event NOW!
  uint32_t chn;                                               // channel
  uint32_t servEvt;                                           // service event
  uint32_t servOffs;                                          // offset for service event
  int32_t  tJump;                                             // diff between expected and actual start of UNILAC cycle
  uint64_t tExpect;                                           // expected start of UNILAC cycle


  status = actStatus;
  
  // wait for MIL event
  milStatus = wait4MILEvent(&evtData, &evtCode, &virtAcc, WRUNIPZ_MILTIMEOUT);
  if (milStatus == WRUNIPZ_STATUS_TIMEDOUT) return WRUNIPZ_STATUS_NOMILEVENTS; // error: no MIL event, maybe dead UNIPZ?
  if (milStatus != WRUNIPZ_STATUS_OK)       return WRUNIPZ_STATUS_MIL;         // some other error

  tMIL      = getSysTime();

  switch (evtCode) {

  case WRUNIPZ_EVT_50HZ_SYNCH :                               // next UNILAC cycle starts
    (*nCycle)++;
    DBPRINT3("wr-unipz: 50Hz, data %d, evtcode %d, virtAcc %d\n", evtData, evtCode, virtAcc);

    // get timestamp from TLU -> ECA
    ecaAction = wait4ECAEvent(WRUNIPZ_ECATIMEOUT, &deadline, &flagIsLate);
    
    // check, if timestamping via TLU failed
    if (ecaAction == WRUNIPZ_ECADO_TIMEOUT) {      
      deadline = tMIL;                                        // continue with TS from MIL
      status   = WRUNIPZ_STATUS_NOTIMESTAMP;
    } // if ecaAction
    
    // check, if timestamps form TLU and MIL are out of order
    if (deadline > tMIL) {
      deadline = tMIL;                                        // continue with TS from MIL
      status   = WRUNIPZ_STATUS_ORDERTIMESTAMP;
    } // if deadline
    
    // check, if timestamp from TLU is not reasonable
    if ((tMIL - deadline) > WRUNIPZ_MATCHWINDOW) {
      deadline = tMIL;                                        // continue with TS from MIL
      status   = WRUNIPZ_STATUS_BADTIMESTAMP;
    } // if tMIL
    

    ebm_clr();

    // walk through all PZs and run requested virt acc (non-prep events)
    tExpect     = syncPrevT + syncPrevLen;                    // expected start of 50 Hz trigger (with data from the previous cycle)
    nLateLocal  = nLate;                                      // for bookkepping for late messages
    syncPrevLen = deadline - syncPrevT;                       // required for 'prep events of next UNILAC cycle'
    syncPrevT   = deadline;                                   // required for 'prep events of next UNILAC cycle'
    isPrepFlag  = 0;                                          // 50 Hz synch: no preparation - use actual deadline from TLU
    for (i=0; i < WRUNIPZ_NPZ; i++) {
      if (nextVacc[i] != 0xffffffff) {
        actVacc[i] = nextVacc[i];                             // remember vacc for actual cycle
        actChan[i] = nextChan[i],
        pzRunVacc(bigData[i][nextChan[i] * WRUNIPZ_NVACC + nextVacc[i]], deadline, i, nextVacc[i], isPrepFlag); // run vaccs
        DBPRINT3("wr-unipz: playing pz %d, vacc %d\n", i, nextVacc[i]);
      } // if nextVacc
    } // for i
    
    if ((nLate != nLateLocal) && (status == WRUNIPZ_STATUS_OK)) status = WRUNIPZ_STATUS_LATE;
    DBPRINT3("wr-unipz: vA played:  %x %x %x %x %x %x %x\n", nextVacc[0], nextVacc[1], nextVacc[2], nextVacc[3], nextVacc[4], nextVacc[5], nextVacc[6]);

    // at this point we have scheduled all timing messages of the running cycle and completed the real-time critical stuff
    // now we can do other things...
    
    tJump       = (int32_t)(tExpect - deadline);              // this is how the start of this UNILAC cycle jumped
    if (tJump > cycJmpMax) cycJmpMax = tJump;
    if (tJump < cycJmpMin) cycJmpMin = tJump;
    
    if (flagClearAllPZ)        {clearAllPZ();           flagClearAllPZ = 0;       }
    if (flagTransactionInit)   {configTransactInit();   flagTransactionInit = 0;  }  /* chk: error handling */
    /* chk !!! what is the mechanism that makes sure that data are committed to all PZs simultanously ??????????????? */
    /* chk !!! bug: in the same cycle where data becomes commited the routine getVacclen will fail (fix after we know commit mechanism) !!! */ 
    
    // reset requested virt accs; flush ECA queue
    for (i=0; i < WRUNIPZ_NPZ; i++) nextVacc[i] = 0xffffffff; // 0xffffffff: no virt acc for PZ
    while (wait4ECAEvent(0, &tDummy, &flagIsLate) !=  WRUNIPZ_ECADO_TIMEOUT) {asm("nop");}

    break;
    
  case WRUNIPZ_EVT_PZ1 ... WRUNIPZ_EVT_PZ7 :                  // super PZ announces what happens in next UNILAC cycle
    // extract information from event from super PZ
    ipz            = evtCode - 1;                             // PZ: sPZ counts from 1..7, we count from 0..6
    nextVacc[ipz]  = virtAcc;
    chn            =  ((evtData & WRUNIPZ_EVTDATA_CHANNEL) != 0); // use relevant bit as channel number (there are only two channels)
    
    // there are two different types of announce events
    // A: The announce event contains information about the vacc to played in the next cycle
    //    In this case 1. handle chopper mode, 2. send all 'prep events'
    // B: The announce event contains information about a service event to be sent
    //    In this case we just take care of the service event and nothing else

    if ((evtData & WRUNIPZ_EVTDATA_SERVICE) == 0) {           // A: super PZ has announced vacc for next cycle: bits 12 (channel number), bits 13..15 (chooper mode)
      DBPRINT3("wr-unipz: playing prep events, pz %d, vacc %d\n", ipz, virtAcc);
      // get chopper mode
      nextChan[ipz]    = chn;
      nextNochop[ipz]  = ((evtData & WRUNIPZ_EVTDATA_NOCHOP)  != 0);

      // PZ1..7: preperation; as the next cycle has been announced, we may send all 'prep events' already now
      // as deadline, we use the deadline from past 50 Hz tick and add the actual UNILAC cycle length
      nLateLocal = nLate;
      isPrepFlag = 1;                                                  
      deadline   = syncPrevT + syncPrevLen;                   // guess start time of next UNILAC cycle from previous cycle
      pzRunVacc(bigData[ipz][chn * WRUNIPZ_NVACC + virtAcc], deadline, ipz, virtAcc, isPrepFlag);
      if ((nLate != nLateLocal) && (status == WRUNIPZ_STATUS_OK)) status = WRUNIPZ_STATUS_LATE;
    } // if !SERVICE
    else {                                                    // B: super PZ has sent info on a service event: bits 12..15 encode event type
      DBPRINT3("wr-unipz: service event for pz %d, vacc %d\n", ipz, virtAcc);
      servOffs = getVaccLen(bigData[ipz][chn * WRUNIPZ_NVACC + virtAcc]) & 0xffff;
      servEvt  = 0x0;
      if (evtData == WRUNIPZ_EVTDATA_PREPACC) {
        servEvt = EVT_AUX_PRP_NXT_ACC | ((virtAcc & 0xf) << 8) | ((servOffs & 0xffff)        << 16); // send after last event of current PZ cycle
        ebmWriteTM(servEvt, syncPrevT, ipz, virtAcc, 0);                                             // send message
      } // if PREPACC
      if (evtData == WRUNIPZ_EVTDATA_ZEROACC) {
        servEvt = EVT_MAGN_DOWN       | ((virtAcc & 0xf) << 8) | ((servOffs & 0xffff)        << 16); // send after last event of current PZ cycle
        ebmWriteTM(servEvt, syncPrevT, ipz, virtAcc, 0);                                             // send message
      } // if ZEROACC
      if (evtData == WRUNIPZ_EVTDATA_PREPACCNOW) {
        servEvt = EVT_AUX_PRP_NXT_ACC | ((virtAcc & 0xf) << 8) | ((uint16_t)WRUNIPZ_QQOFFSET << 16); // send 'now' /* chk QQOFFSET */
        ebmWriteTM(servEvt, getSysTime(), ipz, virtAcc, 0);                                          // send message
      } // if PREPACCNOW
    } // else SERVICE
  
    break;
    
  case WRUNIPZ_EVT_SYNCH_DATA :                               // super PZ commits recently supplied virt acc -> replace active data by the new ones
    if (flagTransactionSubmit) {
      configTransactSubmit();                                 // this takes 51us /* chk: error handling */
      flagTransactionSubmit = 0;
    }  // if transaction submit
    
    break;
    
  default :
    break;
  } // switch evtCode

  return status;
} // doActionOperation

// do autorecovery from error state
uint32_t doAutoRecovery(uint32_t actState, uint32_t *reqState)
{
  switch (actState)
    {
    case WRUNIPZ_STATE_ERROR :
      DBPRINT3("wr-unipz: attempting autorecovery ERROR -> IDLE\n");
      usleep(10000000);
      *reqState = WRUNIPZ_STATE_IDLE; 
      break;
    case WRUNIPZ_STATE_IDLE :
      DBPRINT3("wr-unipz: attempting autorecovery IDLE -> CONFIGURED\n");
      usleep(5000000);
      *reqState =  WRUNIPZ_STATE_CONFIGURED;
      break;
    case WRUNIPZ_STATE_CONFIGURED :
      DBPRINT3("wr-unipz: attempting autorecovery CONFIGURED -> OPREADY\n");
      usleep(5000000);
      *reqState =  WRUNIPZ_STATE_OPREADY;
      break;
    default : ;
    } // switch actState
} // doAutoRecovery


void main(void) {
 
  uint32_t j;
 
  uint32_t status;                                            // (error) status
  uint32_t actState;                                          // actual FSM state
  uint32_t reqState;                                          // requested FSM state
  uint32_t flagRecover;                                       // flag indicating auto-recovery from error state;  

  mprintf("\n");
  mprintf("wr-unipz: ***** firmware v %06d started from scratch *****\n", WRUNIPZ_FW_VERSION);
  mprintf("\n");
  
  // init local variables
  reqState       = WRUNIPZ_STATE_S0;
  actState       = WRUNIPZ_STATE_UNKNOWN;
  status         = WRUNIPZ_STATUS_OK;
  flagRecover    = 0;
  clearDiag();

  init();                                                     // initialize stuff for lm32
  initSharedMem();                                            // initialize shared memory
  
  while (1) {
    cmdHandler(&reqState);                                    // check for commands and possibly request state changes
    status = WRUNIPZ_STATUS_OK;                               // reset status for each iteration
    status = changeState(&actState, &reqState, status);       // handle requested state changes
    switch(actState)                                          // state specific do actions
      {
      case WRUNIPZ_STATE_S0 :
        status = doActionS0();                                              // important initialization that must succeed!
        if (status != WRUNIPZ_STATUS_OK) reqState = WRUNIPZ_STATE_FATAL;    // failed:  -> FATAL
        else                             reqState = WRUNIPZ_STATE_IDLE;     // success: -> IDLE
        break;
      case WRUNIPZ_STATE_OPREADY :
        flagRecover = 0;
        status = doActionOperation(&nCycleAct, status);
        if (status == WRUNIPZ_STATUS_WRBADSYNC)      reqState = WRUNIPZ_STATE_ERROR;
        if (status == WRUNIPZ_STATUS_ERROR)          reqState = WRUNIPZ_STATE_ERROR;
        break;
      case WRUNIPZ_STATE_ERROR :
        flagRecover = 1;                                      // start autorecovery
        break; 
      case WRUNIPZ_STATE_FATAL :
        *pSharedState     = actState;
        *pSharedSumStatus = sumStatus;
        mprintf("wr-unipz: a FATAL error has occured. Good bye.\n");
        while (1) asm("nop"); // RIP!
        break;
      default :                                               // avoid flooding WB bus with unnecessary activity
        for (j = 0; j < (WRUNIPZ_DEFAULT_TIMEOUT * WRUNIPZ_MS_ASMNOP); j++) { asm("nop"); }
      } // switch

    // autorecovery from state ERROR
    if (flagRecover) doAutoRecovery(actState, &reqState);

    // update shared memory
    if (nCycleAct != nCyclePrev) {                            // update only once per cycle 
      if ((nCycleAct % WRUNIPZ_UNILACFREQ) == 0) {            // about only once per second
        
        // length of UNILAC cycle [ns]
        *pSharedTCycleAvg  = (uint32_t)(syncPrevLen);
       
        // message rate [Hz]
        *pSharedMsgFreqAvg = (uint32_t)(nMsgAct - nMsgPrev);
        nMsgPrev           = nMsgAct;

        // virt acc and pz info
        *pSharedVaccAvg    = vaccAvg;
        *pSharedPzAvg      = pzAvg;
        vaccAvg            = 0;
        pzAvg              = 0;
      } // if nCycleAct %
      
      // reset status (hackish solution); chk: consider changing status info to bits encoded into a 32bit number 
      // if ((nCycleAct % (WRUNIPZ_UNILACFREQ * 5)) == 0) status = WRUNIPZ_STATUS_OK; 
        
      nCyclePrev = nCycleAct;
    } // if nCycleAct

    switch (status) {
    case WRUNIPZ_STATUS_OK :                                   // status OK
      sumStatus = sumStatus |  (0x1 << WRUNIPZ_STATUS_OK);     // set OK bit
      break;
    default :                                                  // status not OK
      if ((sumStatus >> WRUNIPZ_STATUS_OK) & 0x1) nBadStatus++;// changing status from OK to 'not OK': increase 'bad status count'
      sumStatus = sumStatus & ~(0x1 << WRUNIPZ_STATUS_OK);     // clear OK bit
      sumStatus = sumStatus |  (0x1 << status);                // set status bit and remember other bits set
      break;
    } // switch status

    if ((*pSharedState     == WRUNIPZ_STATE_OPREADY) && (actState  != WRUNIPZ_STATE_OPREADY)) nBadState++;
    *pSharedSumStatus    = sumStatus;
    *pSharedState        = actState;
    *pSharedNBadStatus   = nBadStatus;
    *pSharedNBadState    = nBadState;
    *pSharedDtMax        = dtMax;
    *pSharedDtMin        = dtMin;
    *pSharedCycJmpMax    = cycJmpMax;
    *pSharedCycJmpMin    = cycJmpMin;
    *pSharedNLate        = nLate;
    *pSharedNCycle       = nCycleAct; 
    *pSharedNMessageHi   = (uint32_t)(nMsgAct >> 32);
    *pSharedNMessageLo   = (uint32_t)(nMsgAct & 0xffffffff);
  } // while  
} // main
