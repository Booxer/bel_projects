#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdlib.h>
#include "pp-printf.h"
#include "mini_sdb.h"
#include "sdb_arg.h"
#include "uart.h"
#include "irq.h"
#include "ethernet.h"
#include <unistd.h>

#define WORDS_MEMORY    0
#define FRAMES_MEMORY   4
#define WORDS_FRAME     8
#define OVERFLOW_RAM    12
#define TIME_STAMP      16
#define TIME_STAMP_ID   20
#define OTHERS_WB       24

#define WR_PPS_GEN_CNTR_UTCLO   0x8

volatile uint8_t *BASE_FRAME_RAM = (uint8_t *) 0x100000;
volatile uint8_t *BASE_FR2WB     = (uint8_t *) 0x800000;

int frame = 0;

void init()
{
   enable_irq();
   discoverPeriphery();
   uart_init_hw();
   uart_write_string("\nDebug Port\n");
}

int main(void) {
  uint32_t frames_read = 0;
  uint32_t overflow = 0;
  uint32_t word = 0;
  uint32_t frame[ETH_FRAME];
  uint32_t frame_b;
  uint32_t header[ETH_HEADER];
  uint32_t fec_header[ETH_HEADER];
  uint32_t fec_payload[ETH_HEADER];
  uint32_t frame_cnt = 0;
  uint32_t ram_s = 0;

  uint32_t frames_ram = 0;
  uint32_t words_in_frame = 50;
  uint32_t cnt;
  uint16_t protocol;
  uint32_t frame_chunk;
  uint32_t counter_h;
  uint32_t counter_l;
  uint32_t time_stamp;
  uint32_t mask;
  uint16_t num_1,num_2;

  init();

  pp_printf("FEC Unit starting!\n");
  pp_printf("SDB Record %x \n", r_sdb_add());
  pp_printf("FEC Wb %x \n",*(volatile uint32_t *)(BASE_FR2WB+OTHERS_WB));
  overflow = *(volatile uint32_t *)(BASE_FR2WB + OVERFLOW_RAM);
  pp_printf("TIME %x \n",*(pPps+2));

  while(1)
  {
    frames_ram = *(volatile uint32_t *)(BASE_FR2WB + FRAMES_MEMORY);
    //pp_printf("Frames in ram %d \n",frames_ram);

    if(frames_ram > 0)
    {
      frames_read = 0;
      frame_cnt = 0;

      while(frames_read < frames_ram)
      {
        for(cnt = 0; cnt < words_in_frame; cnt++)
        {
          frame_chunk = *(volatile uint32_t *)(BASE_FRAME_RAM + (frame_cnt*191) + cnt);
          *(volatile uint32_t *)(BASE_FR2WB + TIME_STAMP_ID) = frames_read;
          time_stamp  = *(volatile uint32_t *)(BASE_FR2WB + TIME_STAMP);

          if (cnt < ETH_HEADER) {
            header[cnt] = frame_chunk;
            pp_printf("%04x%04x",header[cnt]&MASK_HEADER,header[cnt]>>16 );
          } else if (cnt == ETH_HEADER) {
            header[cnt] = frame_chunk&MASK_HEADER;
            pp_printf(":%04x \t",header[cnt]);
            protocol = frame_chunk;
            pp_printf("TS: %08x", time_stamp);
            //if (protocol = 0x1) {
              //pp_printf("Sending HERE I AM \n");
              //break;
            //}
          } else if ( cnt > ETH_HEADER ) {

            num_1 = (uint16_t)(frame_chunk >> 16);
            num_2 = (uint16_t)(frame_chunk & MASK_SWAP);

            for (mask = num_2 >>1; mask != 0; mask = mask >> 1){
              num_2 = num_2 ^ mask;
            }

            for (mask = num_1 >>1; mask != 0; mask = mask >> 1){
              num_1 = num_1 ^ mask;
            }
            if (num_2 + 1 != num_1) {
              if ( num_2 != 65535 && num_1 != 1)
              {
                pp_printf("  ERROR %d ", num_2);
                pp_printf("%d ", num_1);
              }
            }

            //pp_printf("\t%d",num_2);
            //pp_printf("\t%d",num_1);

          }
//          } else if (cnt < ETH_HEADER + 1) {
//            counter_h = frame_chunk;
//          } else if (cnt < ETH_HEADER + 2) {
//            counter_l = frame_chunk;
//          } else {
//            pp_printf("ID:\t %08x%08x \t\t\t TS:\t %08x \n",counter_h,counter_l,time_stamp);
//            break;
//          }
        }
        pp_printf("\n");

        if (frame_cnt == 3)
          frame_cnt = 0;
        else
          frame_cnt++;

        frames_read++;
      }
    }
  }

//    overflow = *(volatile uint32_t *)(BASE_FR2WB + OVERFLOW_RAM);
//    if (overflow != 0)
//      pp_printf("Overflow %x \n",overflow);
//
//    frames_ram = *(volatile uint32_t *)(BASE_FR2WB + FRAMES_MEMORY);
//
//    if(frames_ram > 0)
//    {
//      frames_read = 0;
//      frame_cnt = 0;
//
//      while(frames_read < frames_ram)
//      {
//        for(cnt=0;cnt<words_frame;cnt++)
//        {
//          pp_printf("%x ",*(volatile uint32_t *)(BASE_FRAME_RAM + (frame_cnt*191) + cnt));
//        }
//        pp_printf("\n");
//
//        if (frame_cnt == 3)
//          frame_cnt = 0;
//        else
//          frame_cnt++;
//
//        frames_read++;
//      }
//    }


  //disable_irq();
  return 0;

}
