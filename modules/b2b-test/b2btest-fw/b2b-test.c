/********************************************************************************************
 *  b2b-test.c
 *
 *  created : 2019
 *  author  : Dietrich Beck, GSI-Darmstadt
 *  version : 15-Apr-2019
 *
 *  test program for B2B stuff
 *  
 * -------------------------------------------------------------------------------------------
 * License Agreement for this software:
 *
 * Copyright (C) 2018  Dietrich Beck
 * GSI Helmholtzzentrum fuer Schwerionenforschung GmbH
 * Planckstrasse 1
 * D-64291 Darmstadt
 * Germany
 *
 * Contact: d.beck@gsi.de
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 3 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *  
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library. If not, see <http://www.gnu.org/licenses/>.
 *
 * For all questions and ideas contact: d.beck@gsi.de
 * Last update: 15-April-2019
 ********************************************************************************************/
#define B2BTEST_FW_VERSION 0x000001                                     // make this consistent with makefile

/* standard includes */
#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include <stdint.h>
#include "mprintf.h"
#include "mini_sdb.h"

/* includes specific for bel_projects */
#include "irq.h"
#include "ebm.h"
#include "aux.h"
#include "dbg.h"
#include "../../../top/gsi_scu/scu_mil.h"                               // register layout of 'MIL macro'
#include "../../../ip_cores/wr-cores/modules/wr_eca/eca_queue_regs.h"   // register layout ECA queue
#include "../../../ip_cores/wr-cores/modules/wr_eca/eca_regs.h"         // register layout ECA control
/*                                                                      
#include "../../../ip_cores/wr-cores/modules/wr_pps_gen/pps_gen_regs.h" // useless register layout, I can't handle this wbgen stuff here
*/
#define WR_PPS_GEN_ESCR         0x1c                                    // External Sync Control Register
#define WR_PPS_GEN_ESCR_MASK    0xC                                     // bit 2: PPS valid, bit 3: timestamp valid

#define WR_ENDPOINT             0x650c2d4f                              // WR-endpoint
#define WR_ENDPOINT_MACHI       0x24                                    // MAC high bytes
#define WR_ENDPOINT_MACLO       0x28                                    // MAC low bytes

#include "../../../ip_cores/saftlib/drivers/eca_flags.h"                // definitions for ECA queue

#include <b2b-test.h>                                                   // defs
#include <b2btest_shared_mmap.h>                                        // autogenerated upon building firmware


const char* b2btest_state_text(uint32_t code) {
  switch (code) {
  case B2BTEST_STATE_UNKNOWN      : return "UNKNOWN   ";
  case B2BTEST_STATE_S0           : return "S0        ";
  case B2BTEST_STATE_IDLE         : return "IDLE      ";                                       
  case B2BTEST_STATE_CONFIGURED   : return "CONFIGURED";
  case B2BTEST_STATE_OPREADY      : return "opReady   ";
  case B2BTEST_STATE_STOPPING     : return "STOPPING  ";
  case B2BTEST_STATE_ERROR        : return "ERROR     ";
  case B2BTEST_STATE_FATAL        : return "FATAL(RIP)";
  default                         : return "undefined ";
  }
}

// stuff required for environment
extern uint32_t* _startshared[];
unsigned int     cpuId, cpuQty;
#define  SHARED  __attribute__((section(".shared")))
uint64_t SHARED  dummy = 0;

// global variables 
volatile uint32_t *pECAQ;               // WB address of ECA queue
volatile uint32_t *pPPSGen;             // WB address of PPS Gen
volatile uint32_t *pWREp;               // WB address of WR Endpoint

volatile uint32_t *pShared;             // pointer to begin of shared memory region
uint32_t *pSharedVersion;               // pointer to a "user defined" u32 register; here: publish version
uint32_t *pSharedSumStatus;             // pointer to a "user defined" u32 register; here: publish OR of all (actual) error bits
uint32_t *pSharedNBadStatus;            // pointer to a "user defined" u32 register; here: publish # of bad status (=error) incidents
uint32_t *pSharedNBadState;             // pointer to a "user defined" u32 register; here: publish # of bad state (=FATAL, ERROR, UNKNOWN) incidents
volatile uint32_t *pSharedCmd;          // pointer to a "user defined" u32 register; here: get command from host
uint32_t *pSharedState;                 // pointer to a "user defined" u32 register; here: publish status
volatile uint32_t *pSharedData4EB;      // pointer to a n x u32 register; here: memory region for receiving EB return values
uint32_t *pSharedMacHi;                 // pointer to a "user defined" u32 register; here: high bits of MAC
uint32_t *pSharedMacLo;                 // pointer to a "user defined" u32 register; here: low bits of MAC
uint32_t *pSharedIp;                    // pointer to a "user defined" u32 register; here: IP
uint32_t *pSharedNTransfer;             // pointer to a "user defined" u32 register; here: # of transfers
uint32_t *pSharedTDiagHi;               // pointer to a "user defined" u32 register; here: time when diag was cleared, high bits
uint32_t *pSharedTDiagLo;               // pointer to a "user defined" u32 register; here: time when diag was cleared, low bits
uint32_t *pSharedTS0Hi;                 // pointer to a "user defined" u32 register; here: time when FW was in S0 state, high bits
uint32_t *pSharedTS0Lo;                 // pointer to a "user defined" u32 register; here: time when FW was in S0 state, low bits

uint32_t *pCpuRamExternal;              // external address (seen from host bridge) of this CPU's RAM            
uint32_t *pCpuRamExternalData4EB;       // external address (seen from host bridge) of this CPU's RAM: field for EB return values

uint32_t sumStatus;                     // all status infos are ORed bit-wise into sum status, sum status is then published
uint32_t nBadStatus;                    // # of bad status (=error) incidents
uint32_t nBadState;                     // # of bad state (=FATAL, ERROR, UNKNOWN) incidents

uint64_t tH1;                           // rise edge of H = 1 signal


uint64_t wrGetMac() // get my own MAC
{
  uint32_t macHi, macLo;
  uint64_t mac;

  macHi = (*(pWREp + (WR_ENDPOINT_MACHI >> 2))) & 0xffff;
  macLo = *(pWREp + (WR_ENDPOINT_MACLO >> 2));

  mac = macHi;
  mac = (mac << 32);
  mac = mac + macLo;

  return mac;
} // wrGetMac


uint32_t ebmInit(uint32_t msTimeout, uint64_t dstMac, uint32_t dstIp, uint32_t eb_ops) // intialize Etherbone master
{
  uint64_t timeoutT;

  // check IP
  timeoutT = getSysTime() + (uint64_t)msTimeout * (uint64_t)1000000;
  while (timeoutT < getSysTime()) {
    if (*(pEbCfg + (EBC_SRC_IP>>2)) == EBC_DEFAULT_IP) asm("nop");
    else break;
  } // while no IP via DHCP
  if (*(pEbCfg + (EBC_SRC_IP>>2)) == EBC_DEFAULT_IP) return B2BTEST_STATUS_NOIP;

  // init ebm
  ebm_init();
  ebm_config_if(DESTINATION, dstMac    , dstIp,                       0xebd0); 
  ebm_config_if(SOURCE,      wrGetMac(), *(pEbCfg + (EBC_SRC_IP>>2)), 0xebd0); 
  ebm_config_meta(1500, 0x0, eb_ops);
  ebm_clr();

  return B2BTEST_STATUS_OK;
} // ebminit


uint32_t ebmWriteTM()
{
  int      i;
  uint64_t deadline;
  uint32_t res, tef;
  uint32_t deadlineLo, deadlineHi, offset;
  uint32_t idLo, idHi;
  uint32_t paramLo, paramHi;

  // set high bits for EB master
  ebm_hi(B2BTEST_ECA_ADDRESS);

  // pack Ethernet frame with messages
  idHi    = 0x01234567;
  idLo    = 0x89abcdef;
  tef     = 0x00000000;
  res     = 0x00000000;
  paramLo = 0x00000000;
  paramHi = 0x00000000;

  // calc deadline
  deadline   = tH1 + (uint64_t)1000000000 - (uint64_t)50000000; 
  deadlineHi = (uint32_t)((deadline >> 32) & 0xffffffff);
  deadlineLo = (uint32_t)(deadline & 0xffffffff);
          
  // pack timing message
  atomic_on();                                  
  ebm_op(B2BTEST_ECA_ADDRESS, idHi,       EBM_WRITE);             
  ebm_op(B2BTEST_ECA_ADDRESS, idLo,       EBM_WRITE);             
  ebm_op(B2BTEST_ECA_ADDRESS, paramHi,    EBM_WRITE);
  ebm_op(B2BTEST_ECA_ADDRESS, paramLo,    EBM_WRITE);
  ebm_op(B2BTEST_ECA_ADDRESS, tef,        EBM_WRITE);
  ebm_op(B2BTEST_ECA_ADDRESS, res,        EBM_WRITE);
  ebm_op(B2BTEST_ECA_ADDRESS, deadlineHi, EBM_WRITE);
  ebm_op(B2BTEST_ECA_ADDRESS, deadlineLo, EBM_WRITE);
  atomic_off();
          
  // send timing message
  ebm_flush();
          
  // diag and status
  // ... /* chk */
  mprintf("b2b-test: write timing message\n");
  
  return B2BTEST_STATUS_OK;
} //ebmWriteTM


uint32_t wrCheckSyncState() //check status of White Rabbit (link up, tracking)
{
  uint32_t syncState;

  syncState =  *(pPPSGen + (WR_PPS_GEN_ESCR >> 2));                         // read status
  syncState = syncState & WR_PPS_GEN_ESCR_MASK;                             // apply mask

  if ((syncState == WR_PPS_GEN_ESCR_MASK)) return B2BTEST_STATUS_OK;        // check if all relevant bits are set
  else                                     return B2BTEST_STATUS_WRBADSYNC;
} //wrCheckStatus


void init() // typical init for lm32
{
  discoverPeriphery();        // mini-sdb ...
  uart_init_hw();             // needed by WR console   
  cpuId = getCpuIdx();

  timer_init(1);              // needed by usleep_init() 
  usleep_init();              // needed by scu_mil.c

  // set MSI IRQ handler
  isr_table_clr();
  //irq_set_mask(0x01);
  irq_disable();
} // init


void initSharedMem() // determine address and clear shared mem
{
  uint32_t idx;
  uint32_t *pSharedTemp;
  int      i; 
  const uint32_t c_Max_Rams = 10;
  sdb_location found_sdb[c_Max_Rams];
  sdb_location found_clu;
  
  // get pointer to shared memory
  pShared           = (uint32_t *)_startshared;

  // get address to data
  pSharedVersion          = (uint32_t *)(pShared + (B2BTEST_SHARED_VERSION >> 2));
  pSharedSumStatus        = (uint32_t *)(pShared + (B2BTEST_SHARED_SUMSTATUS >> 2));
  pSharedCmd              = (uint32_t *)(pShared + (B2BTEST_SHARED_CMD >> 2));
  pSharedState            = (uint32_t *)(pShared + (B2BTEST_SHARED_STATE >> 2));
  pSharedData4EB          = (uint32_t *)(pShared + (B2BTEST_SHARED_DATA_4EB >> 2));
  pSharedNBadStatus       = (uint32_t *)(pShared + (B2BTEST_SHARED_NBADSTATUS >> 2));
  pSharedNBadState        = (uint32_t *)(pShared + (B2BTEST_SHARED_NBADSTATE >> 2));
  pSharedNTransfer        = (uint32_t *)(pShared + (B2BTEST_SHARED_NTRANSFER >> 2));
  pSharedMacHi            = (uint32_t *)(pShared + (B2BTEST_SHARED_MACHI >> 2));
  pSharedMacLo            = (uint32_t *)(pShared + (B2BTEST_SHARED_MACLO >> 2));
  pSharedIp               = (uint32_t *)(pShared + (B2BTEST_SHARED_IP >> 2));
  pSharedTDiagHi          = (uint32_t *)(pShared + (B2BTEST_SHARED_TDIAGHI >> 2));
  pSharedTDiagLo          = (uint32_t *)(pShared + (B2BTEST_SHARED_TDIAGLO >> 2));
  pSharedTS0Hi            = (uint32_t *)(pShared + (B2BTEST_SHARED_TS0HI >> 2));
  pSharedTS0Lo            = (uint32_t *)(pShared + (B2BTEST_SHARED_TS0LO >> 2));
  
  // find address of CPU from external perspective
  idx = 0;
  find_device_multi(&found_clu, &idx, 1, GSI, LM32_CB_CLUSTER);	
  idx = 0;
  find_device_multi_in_subtree(&found_clu, &found_sdb[0], &idx, c_Max_Rams, GSI, LM32_RAM_USER);
  if(idx >= cpuId) {
    pCpuRamExternal           = (uint32_t *)(getSdbAdr(&found_sdb[cpuId]) & 0x7FFFFFFF); // CPU sees the 'world' under 0x8..., remove that bit to get host bridge perspective
    pCpuRamExternalData4EB    = (uint32_t *)(pCpuRamExternal + ((B2BTEST_SHARED_DATA_4EB + SHARED_OFFS) >> 2));
  }

  DBPRINT2("b2b-test: CPU RAM External 0x%8x, begin shared 0x%08x\n", pCpuRamExternal, SHARED_OFFS);

  // clear shared mem
  i = 0;
  pSharedTemp          = (uint32_t *)(pShared + (B2BTEST_SHARED_BEGIN >> 2 ));
  while (pSharedTemp < (uint32_t *)(pShared + (B2BTEST_SHARED_END >> 2 ))) {
    *pSharedTemp = 0x0;
    pSharedTemp++;
    i++;
  } // while pSharedTemp
  DBPRINT2("b2b-test: used size of shared mem is %d words (uint32_t), begin %x, end %x\n", i, pShared, pSharedTemp-1);
  
  // set initial values;
  *pSharedVersion      = B2BTEST_FW_VERSION; // of all the shared variabes, only VERSION is a constant. Set it now!
  *pSharedNBadStatus   = 0;
  *pSharedNBadState    = 0;
} // initSharedMem 


uint32_t findPPSGen() //find WB address of WR PPS Gen
{
  pPPSGen = 0x0;
  
  // get Wishbone address for PPS Gen
  pPPSGen = find_device_adr(CERN, WR_PPS_GEN);

  if (!pPPSGen) {DBPRINT1("b2b-test: can't find WR PPS Gen\n"); return B2BTEST_STATUS_ERROR;}
  else                                                          return B2BTEST_STATUS_OK;
} // findPPSGen


uint32_t findWREp() //find WB address of WR Endpoint
{
  pWREp = 0x0;
  
  // get Wishbone address for WR Endpoint
  pWREp = find_device_adr(CERN, WR_ENDPOINT);

  if (!pWREp) {DBPRINT1("b2b-test: can't find WR Endpoint\n"); return B2BTEST_STATUS_ERROR;}
  else                                                         return B2BTEST_STATUS_OK;
} // findWREp


uint32_t findECAQueue() // find WB address of ECA channel for LM32
{
#define ECAQMAX           4     // max number of ECA channels in the system
#define ECACHANNELFORLM32 2     // this is a hack! suggest implementing finding via sdb-record and info

  // stuff below needed to get WB address of ECA queue
  sdb_location ECAQ_base[ECAQMAX];
  uint32_t ECAQidx = 0;         
  uint32_t *tmp;                
  int i;

  // get Wishbone address of ECA queue 
  // get list of ECA queues
  find_device_multi(ECAQ_base, &ECAQidx, ECAQMAX, ECA_QUEUE_SDB_VENDOR_ID, ECA_QUEUE_SDB_DEVICE_ID);
  pECAQ = 0x0;

  // find ECA queue connected to ECA chanel for LM32
  for (i=0; i < ECAQidx; i++) {
    tmp = (uint32_t *)(getSdbAdr(&ECAQ_base[i]));  
    if ( *(tmp + (ECA_QUEUE_QUEUE_ID_GET >> 2)) == ECACHANNELFORLM32) pECAQ = tmp;
  }

  if (!pECAQ) {DBPRINT1("b2b-test: can't find ECA queue\n"); return B2BTEST_STATUS_ERROR;}
  else                                                       return B2BTEST_STATUS_OK;
} // findECAQueue


uint32_t wait4ECAEvent(uint32_t msTimeout, uint64_t *deadline, uint32_t *isLate)  // 1. query ECA for actions, 2. trigger activity
{
  uint32_t *pECAFlag;           // address of ECA flag
  uint32_t evtIdHigh;           // high 32bit of eventID   
  uint32_t evtIdLow;            // low 32bit of eventID    
  uint32_t evtDeadlHigh;        // high 32bit of deadline  
  uint32_t evtDeadlLow;         // low 32bit of deadline   
  uint32_t evtParamHigh;        // high 32 bit of parameter field
  uint32_t evtParamLow ;        // low 32 bit of parameter field
  uint32_t evtTef;              // 32 bit TEF field
  uint32_t actTag;              // tag of action           
  uint32_t nextAction;          // describes what to do next
  uint64_t timeoutT;            // when to time out


  pECAFlag    = (uint32_t *)(pECAQ + (ECA_QUEUE_FLAGS_GET >> 2));   // address of ECA flag

  timeoutT    = getSysTime() + (uint64_t)msTimeout * (uint64_t)1000000 + (uint64_t)1000; 
  
  while (getSysTime() < timeoutT) {
    if (*pECAFlag & (0x0001 << ECA_VALID)) {                        // if ECA data is valid

      // read data
      evtIdHigh    = *(pECAQ + (ECA_QUEUE_EVENT_ID_HI_GET >> 2));
      evtIdLow     = *(pECAQ + (ECA_QUEUE_EVENT_ID_LO_GET >> 2));
      evtDeadlHigh = *(pECAQ + (ECA_QUEUE_DEADLINE_HI_GET >> 2));
      evtDeadlLow  = *(pECAQ + (ECA_QUEUE_DEADLINE_LO_GET >> 2));
      actTag       = *(pECAQ + (ECA_QUEUE_TAG_GET >> 2));
      evtParamHigh = *(pECAQ + (ECA_QUEUE_PARAM_HI_GET >> 2));
      evtParamLow  = *(pECAQ + (ECA_QUEUE_PARAM_LO_GET >> 2));
      evtTef       = *(pECAQ + (ECA_QUEUE_TEF_GET >> 2));
      *isLate      = *pECAFlag & (0x0001 << ECA_LATE);

      *deadline    = ((uint64_t)evtDeadlHigh << 32) + (uint64_t)evtDeadlLow;
      
      // pop action from channel
      *(pECAQ + (ECA_QUEUE_POP_OWR >> 2)) = 0x1;

      // here: do s.th. according to tag
      switch (actTag) {
      case B2BTEST_ECADO_PHASE :
        nextAction = B2BTEST_ECADO_PHASE;
        break;
      case B2BTEST_ECADO_INPUT :
        nextAction = B2BTEST_ECADO_INPUT;
        break;
      default: 
        nextAction = B2BTEST_ECADO_UNKOWN;
        break;
      } // switch

      return nextAction;

    } // if data is valid
  } // while not timed out

  return  B2BTEST_ECADO_TIMEOUT;
} // wait for ECA event


void initCmds() // init stuff for handling commands, trivial for now, will be extended
{
  //  initalize command value: 0x0 means 'no command'
  *pSharedCmd     = 0x0;
} // initCmds

 
void clearDiag() // clears all statistics
{
  uint64_t now;
  
  sumStatus      = 0;
  nBadStatus     = 0;

  now = getSysTime();
  *pSharedTDiagHi = (uint32_t)(now >> 32);
  *pSharedTDiagLo = (uint32_t)now & 0xffffffff;

} // clearDiag


uint32_t doActionS0()
{
  uint32_t status = B2BTEST_STATUS_OK;
  uint64_t now;

  if (findECAQueue() != B2BTEST_STATUS_OK) status = B2BTEST_STATUS_ERROR; 
  if (findPPSGen()   != B2BTEST_STATUS_OK) status = B2BTEST_STATUS_ERROR;
  if (findWREp()     != B2BTEST_STATUS_OK) status = B2BTEST_STATUS_ERROR;

  nBadState     = 0;
  now           = getSysTime();
  *pSharedTS0Hi = (uint32_t)(now >> 32);
  *pSharedTS0Lo = (uint32_t)now & 0xffffffff;
  
  initCmds();                    

  return status;
} // doActionS0


uint32_t entryActionConfigured()
{
  uint32_t status = B2BTEST_STATUS_OK;
  uint64_t mac;
  uint32_t ip;

  // configure EB master (SRC and DST MAC/IP are set from host)
  //  ebmInit(100, 0xffffffffffff, 0xffffffff, EBM_NOREPLY);
  if ((status = ebmInit(2000, 0xffffffffffff, 0xffffffff, EBM_NOREPLY)) != B2BTEST_STATUS_OK) {
    DBPRINT1("b2b-test: ERROR - init of EB master failed! %d\n", status);
    return status;
  } 

  // get and publish NIC data
  mac = wrGetMac();
  *pSharedMacHi = (uint32_t)(mac >> 32) & 0xffff;
  *pSharedMacLo = (uint32_t)mac         & 0xffffffff;

  ip  = *(pEbCfg + (EBC_SRC_IP>>2));
  *pSharedIp    = ip;

  return status;
} // entryActionConfigured


uint32_t entryActionOperation()
{
  int      i;
  uint64_t tDummy;
  uint32_t flagDummy;
  
  clearDiag();                                               // clear diagnostics

  // flush ECA queue for lm32
  i = 0;
  while (wait4ECAEvent(1, &tDummy, &flagDummy) !=  B2BTEST_ECADO_TIMEOUT) {i++;}
  DBPRINT1("b2b-test: ECA queue flushed - removed %d pending entries from ECA queue\n", i);

  return B2BTEST_STATUS_OK;
} // entryActionOperation


uint32_t exitActionOperation(){
  return B2BTEST_STATUS_OK;
} // exitActionOperation

uint32_t exitActionError()
{
  return B2BTEST_STATUS_OK;
} // exitActionError


void cmdHandler(uint32_t *reqState) // handle commands from the outside world
{
  uint32_t cmd;

  cmd = *pSharedCmd;
  // check, if the command is valid and request state change
  if (cmd) {
    switch (cmd) {
    case B2BTEST_CMD_CONFIGURE :
      *reqState =  B2BTEST_STATE_CONFIGURED;
      DBPRINT3("b2b-test: received cmd %d\n", cmd);
      break;
    case B2BTEST_CMD_STARTOP :
      *reqState = B2BTEST_STATE_OPREADY;
      DBPRINT3("b2b-test: received cmd %d\n", cmd);
      break;
    case B2BTEST_CMD_STOPOP :
      *reqState = B2BTEST_STATE_STOPPING;
      DBPRINT3("b2b-test: received cmd %d\n", cmd);
      break;
    case B2BTEST_CMD_IDLE :
      *reqState = B2BTEST_STATE_IDLE;
      DBPRINT3("b2b-test: received cmd %d\n", cmd);
      break;
    case B2BTEST_CMD_RECOVER :
      *reqState = B2BTEST_STATE_IDLE;
      DBPRINT3("b2b-test: received cmd %d\n", cmd);
      break;
    case B2BTEST_CMD_CLEARDIAG :
      DBPRINT3("b2b-test: received cmd %d\n", cmd);
      clearDiag();
      break;
    default:
      DBPRINT3("b2b-test: received unknown command '0x%08x'\n", cmd);
    } // switch 
    *pSharedCmd = 0x0; // reset cmd value in shared memory 
  } // if command 
} // cmdHandler


uint32_t changeState(uint32_t *actState, uint32_t *reqState, uint32_t actStatus)   //state machine; see b2b-test.h for possible states and transitions
{
  uint32_t statusTransition= B2BTEST_STATUS_OK;
  uint32_t status;
  uint32_t nextState;                   

  // if something severe happened, perform implicitely allowed transition to ERROR or FATAL states
  // else                        , handle explicitcely allowed transitions

  if ((*reqState == B2BTEST_STATE_ERROR) || (*reqState == B2BTEST_STATE_FATAL)) {statusTransition = actStatus; nextState = *reqState;}
  else {
    nextState = *actState;                       // per default: remain in actual state without exit or entry action
    switch (*actState) {                         // check for allowed transitions: 1. determine next state, 2. perform exit or entry actions if required
    case B2BTEST_STATE_S0:
      if      (*reqState == B2BTEST_STATE_IDLE)       {                                            nextState = *reqState;}      
      break;
    case B2BTEST_STATE_IDLE:
      if      (*reqState == B2BTEST_STATE_CONFIGURED)  {statusTransition = entryActionConfigured(); nextState = *reqState;}
      break;
    case B2BTEST_STATE_CONFIGURED:
      if      (*reqState == B2BTEST_STATE_IDLE)       {                                            nextState = *reqState;}
      else if (*reqState == B2BTEST_STATE_CONFIGURED) {statusTransition = entryActionConfigured(); nextState = *reqState;}
      else if (*reqState == B2BTEST_STATE_OPREADY)    {statusTransition = entryActionOperation();  nextState = *reqState;}
      break;
    case B2BTEST_STATE_OPREADY:
      if      (*reqState == B2BTEST_STATE_STOPPING)   {statusTransition = exitActionOperation();   nextState = *reqState;}
      break;
    case B2BTEST_STATE_STOPPING:
      nextState = B2BTEST_STATE_CONFIGURED;      //automatic transition but without entryActionConfigured
    case B2BTEST_STATE_ERROR:
      if      (*reqState == B2BTEST_STATE_IDLE)       {statusTransition = exitActionError();       nextState = *reqState;}
      break;
    default: 
      nextState = B2BTEST_STATE_S0;
    } // switch actState
  }  // else something severe happened
  
  // if the transition failed, transit to error state (except we are already in FATAL state)
  if ((statusTransition != B2BTEST_STATUS_OK) && (nextState != B2BTEST_STATE_FATAL)) nextState = B2BTEST_STATE_ERROR;

  // if the state changes
  if (*actState != nextState) {                   
    mprintf("b2b-test: changed to state %d\n", nextState);
    *actState = nextState;                      
    status = statusTransition;
  } // if state change
  else  status = actStatus;

  *reqState = B2BTEST_STATE_UNKNOWN;             // reset requested state (= no change state requested)  

  return status;
} //changeState


uint32_t doActionOperation(uint64_t *tAct,                    // actual time
                           uint32_t actStatus)                // actual status of firmware
{
  uint32_t status;                                            // status returned by routines
  uint32_t flagIsLate;                                        // flag indicating that we received a 'late' event from ECA
  uint32_t ecaAction;                                         // action triggered by event received from ECA
  uint64_t deadline;                                          // deadline of event received via ECA
  uint64_t tDummy;                                            // dummy timestamp
  int      i,j;
  int      nInput;
  uint32_t tsHi;
  uint32_t tsLo;


  status = actStatus;

  ecaAction = wait4ECAEvent(B2BTEST_ECATIMEOUT, &deadline, &flagIsLate);

  
  
  switch (ecaAction) {
  case B2BTEST_ECADO_PHASE :
    tsHi = (uint32_t)((deadline >> 32) & 0xffffffff);
    tsLo = (uint32_t)(deadline & 0xffffffff);
    mprintf("b2b-test: action phase, action %d, ts %u %u\n", ecaAction, tsHi, tsLo);
    nInput = 0;
    tH1    = 0xffffffffffffffff;
    while (nInput < 2) {                                      // treat 1st input as junk
      ecaAction = wait4ECAEvent(100, &deadline, &flagIsLate);
      tsHi = (uint32_t)((deadline >> 32) & 0xffffffff);
      tsLo = (uint32_t)(deadline & 0xffffffff);
      mprintf("b2b-test: action TLU,   action %d, ts %u %u\n", ecaAction, tsHi, tsLo);
      if (ecaAction == B2BTEST_ECADO_INPUT)   nInput++;
      if (ecaAction == B2BTEST_ECADO_TIMEOUT) break; 
    } // while nInput
    mprintf("b2b-test: action phase, nInput %d\n", nInput);
    
    if (nInput == 2) {
      tH1 = deadline;
      ebmWriteTM();
    } // if nInput
    else actStatus = B2BTEST_STATUS_PHASEFAILED;

    break;
    
  default :
    break;
  } // switch ecaActione

  status = actStatus; /* chk */
  
  return status;
} // doActionOperation

uint32_t doAutoRecovery(uint32_t actState, uint32_t *reqState)                    // do autorecovery from error state
{
  switch (actState)
    {
    case B2BTEST_STATE_ERROR :
      DBPRINT3("b2b-test: attempting autorecovery ERROR -> IDLE\n");
      usleep(10000000);
      *reqState = B2BTEST_STATE_IDLE; 
      break;
    case B2BTEST_STATE_IDLE :
      DBPRINT3("b2b-test: attempting autorecovery IDLE -> CONFIGURED\n");
      usleep(5000000);
      *reqState =  B2BTEST_STATE_CONFIGURED;
      break;
    case B2BTEST_STATE_CONFIGURED :
      DBPRINT3("b2b-test: attempting autorecovery CONFIGURED -> OPREADY\n");
      usleep(5000000);
      *reqState =  B2BTEST_STATE_OPREADY;
      break;
    default : ;
    } // switch actState
} // doAutoRecovery


void main(void) {
 
  uint32_t j;
 
  uint64_t tPrevCycle;                          // time of previous UNILAC cycle
  uint64_t tActCycle;                           // time of actual UNILAC cycle
  uint32_t status;                              // (error) status
  uint32_t actState;                            // actual FSM state
  uint32_t reqState;                            // requested FSM state
  uint32_t flagRecover;                         // flag indicating auto-recovery from error state;  

  mprintf("\n");
  mprintf("b2b-test: ***** firmware v %06d started from scratch *****\n", B2BTEST_FW_VERSION);
  mprintf("\n");
  
  // init local variables
  reqState       = B2BTEST_STATE_S0;
  actState       = B2BTEST_STATE_UNKNOWN;
  status         = B2BTEST_STATUS_OK;
  flagRecover    = 0;
  clearDiag();

  init();                                                                   // initialize stuff for lm32
  initSharedMem();                                                          // initialize shared memory
  
  while (1) {
    cmdHandler(&reqState);                                                  // check for commands and possibly request state changes
    status = B2BTEST_STATUS_OK;                                             // reset status for each iteration
    status = changeState(&actState, &reqState, status);                     // handle requested state changes
    switch(actState)                                                        // state specific do actions
      {
      case B2BTEST_STATE_S0 :
        status = doActionS0();                                              // important initialization that must succeed!
        if (status != B2BTEST_STATUS_OK) reqState = B2BTEST_STATE_FATAL;    // failed:  -> FATAL
        else                             reqState = B2BTEST_STATE_IDLE;     // success: -> IDLE
        break;
      case B2BTEST_STATE_OPREADY :
        flagRecover = 0;
        status = doActionOperation(&tActCycle, status);
        if (status == B2BTEST_STATUS_WRBADSYNC)      reqState = B2BTEST_STATE_ERROR;
        if (status == B2BTEST_STATUS_ERROR)          reqState = B2BTEST_STATE_ERROR;
        break;
      case B2BTEST_STATE_ERROR :
        flagRecover = 1;                                                    // start autorecovery
        break; 
      case B2BTEST_STATE_FATAL :
        *pSharedState     = actState;
        *pSharedSumStatus = sumStatus;
        mprintf("b2b-test: a FATAL error has occured. Good bye.\n");
        while (1) asm("nop"); // RIP!
        break;
      default :                                                             // avoid flooding WB bus with unnecessary activity
        for (j = 0; j < (B2BTEST_DEFAULT_TIMEOUT * B2BTEST_MS_ASMNOP); j++) { asm("nop"); }
      } // switch

    // autorecovery from state ERROR
    if (flagRecover) doAutoRecovery(actState, &reqState);

    // update shared memory
    // ... 
        
    switch (status) {
    case B2BTEST_STATUS_OK :                                                  // status OK
      sumStatus = sumStatus |  (0x1 << B2BTEST_STATUS_OK);                    // set OK bit
      break;
    default :                                                                 // status not OK
      if ((sumStatus >> B2BTEST_STATUS_OK) & 0x1) nBadStatus++;               // changing status from OK to 'not OK': increase 'bad status count'
      sumStatus = sumStatus & ~(0x1 << B2BTEST_STATUS_OK);                    // clear OK bit
      sumStatus = sumStatus |  (0x1 << status);                               // set status bit and remember other bits set
      break;
    } // switch status

    if ((*pSharedState     == B2BTEST_STATE_OPREADY) && (actState  != B2BTEST_STATE_OPREADY)) nBadState++;
    *pSharedSumStatus    = sumStatus;
    *pSharedState        = actState;
    *pSharedNBadStatus   = nBadStatus;
    *pSharedNBadState    = nBadState;
  } // while  
} // main
