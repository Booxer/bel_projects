/********************************************************************************************
 *  b2b-test.c
 *
 *  created : 2019
 *  author  : Dietrich Beck, GSI-Darmstadt
 *  version : 15-Apr-2019
 *
 *  test program for B2B stuff
 *  
 * -------------------------------------------------------------------------------------------
 * License Agreement for this software:
 *
 * Copyright (C) 2018  Dietrich Beck
 * GSI Helmholtzzentrum fuer Schwerionenforschung GmbH
 * Planckstrasse 1
 * D-64291 Darmstadt
 * Germany
 *
 * Contact: d.beck@gsi.de
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 3 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *  
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library. If not, see <http://www.gnu.org/licenses/>.
 *
 * For all questions and ideas contact: d.beck@gsi.de
 * Last update: 15-April-2019
 ********************************************************************************************/
#define B2BTEST_FW_VERSION 0x000001                                     // make this consistent with makefile

/* standard includes */
#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include <stdint.h>
#include "mprintf.h"
#include "mini_sdb.h"

/* includes specific for bel_projects */
#include "irq.h"
#include "ebm.h"
#include "aux.h"
#include "dbg.h"
#include "../../../top/gsi_scu/scu_mil.h"                               // register layout of 'MIL macro'
#include "../../../ip_cores/wr-cores/modules/wr_eca/eca_queue_regs.h"   // register layout ECA queue
#include "../../../ip_cores/wr-cores/modules/wr_eca/eca_regs.h"         // register layout ECA control
/*                                                                      
#include "../../../ip_cores/wr-cores/modules/wr_pps_gen/pps_gen_regs.h" // useless register layout, I can't handle this wbgen stuff here
*/
#define WR_PPS_GEN_ESCR         0x1c                                    // External Sync Control Register
#define WR_PPS_GEN_ESCR_MASK    0xC                                     // bit 2: PPS valid, bit 3: timestamp valid

#define WR_ENDPOINT             0x650c2d4f                              // WR-endpoint
#define WR_ENDPOINT_MACHI       0x24                                    // MAC high bytes
#define WR_ENDPOINT_MACLO       0x28                                    // MAC low bytes

#include "../../../ip_cores/saftlib/drivers/eca_flags.h"                // definitions for ECA queue

#include <b2b-test.h>                                                   // defs
#include <b2btest_shared_mmap.h>                                        // autogenerated upon building firmware


const char* b2btest_state_text(uint32_t code) {
  switch (code) {
  case B2BTEST_STATE_UNKNOWN      : return "UNKNOWN   ";
  case B2BTEST_STATE_S0           : return "S0        ";
  case B2BTEST_STATE_IDLE         : return "IDLE      ";                                       
  case B2BTEST_STATE_CONFIGURED   : return "CONFIGURED";
  case B2BTEST_STATE_OPREADY      : return "opReady   ";
  case B2BTEST_STATE_STOPPING     : return "STOPPING  ";
  case B2BTEST_STATE_ERROR        : return "ERROR     ";
  case B2BTEST_STATE_FATAL        : return "FATAL(RIP)";
  default                         : return "undefined ";
  }
}

// stuff required for environment
extern uint32_t* _startshared[];
unsigned int     cpuId, cpuQty;
#define  SHARED  __attribute__((section(".shared")))
uint64_t SHARED  dummy = 0;

// global variables 
volatile uint32_t *pECAQ;               // WB address of ECA queue
volatile uint32_t *pMILPiggy;           // WB address of MIL device bus (MIL piggy)
volatile uint32_t *pPPSGen;             // WB address of PPS Gen
volatile uint32_t *pWREp;               // WB address of WR Endpoint

volatile uint32_t *pShared;             // pointer to begin of shared memory region
uint32_t *pSharedVersion;               // pointer to a "user defined" u32 register; here: publish version
uint32_t *pSharedSumStatus;             // pointer to a "user defined" u32 register; here: publish OR of all (actual) error bits
uint32_t *pSharedNBadStatus;            // pointer to a "user defined" u32 register; here: publish # of bad status (=error) incidents
uint32_t *pSharedNBadState;             // pointer to a "user defined" u32 register; here: publish # of bad state (=FATAL, ERROR, UNKNOWN) incidents
volatile uint32_t *pSharedCmd;          // pointer to a "user defined" u32 register; here: get command from host
uint32_t *pSharedState;                 // pointer to a "user defined" u32 register; here: publish status
volatile uint32_t *pSharedData4EB;      // pointer to a n x u32 register; here: memory region for receiving EB return values
uint32_t *pSharedMacHi;                 // pointer to a "user defined" u32 register; here: high bits of MAC
uint32_t *pSharedMacLo;                 // pointer to a "user defined" u32 register; here: low bits of MAC
uint32_t *pSharedIp;                    // pointer to a "user defined" u32 register; here: IP
uint32_t *pSharedNMessageHi;            // pointer to a "user defined" u32 register; here: high bits # of messages
uint32_t *pSharedNMessageLo;            // pointer to a "user defined" u32 register; here: lo bits # of messages
uint32_t *pSharedMsgFreqAvg;            // pointer to a "user defined" u32 register; here: message rate (average over one second)
uint32_t *pSharedDtMax;                 // pointer to a "user defined" u32 register; here: max diff between deadline and time of dispatching
uint32_t *pSharedDtMin;                 // pointer to a "user defined" u32 register; here: min diff between deadline and time of dispatching
uint32_t *pSharedNLate;                 // pointer to a "user defined" u32 register; here: # late messages
uint32_t *pSharedVaccAvg;               // pointer to a "user defined" u32 register; here: virt accs played during past second
uint32_t *pSharedPzAvg;                 // pointer to a "user defined" u32 register; here: PZs used during the past second
uint32_t *pSharedMode;                  // pointer to a "user defined" u32 register; here: mode (see B2BTEST_MODE...)
uint32_t *pSharedTDiagHi;               // pointer to a "user defined" u32 register; here: time when diag was cleared, high bits
uint32_t *pSharedTDiagLo;               // pointer to a "user defined" u32 register; here: time when diag was cleared, low bits
uint32_t *pSharedTS0Hi;                 // pointer to a "user defined" u32 register; here: time when FW was in S0 state, high bits
uint32_t *pSharedTS0Lo;                 // pointer to a "user defined" u32 register; here: time when FW was in S0 state, low bits
uint32_t *pSharedConfStat;              // pointer to a "user defined" u32 register; here: status of config data transaction
uint32_t *pSharedConfVacc;              // pointer to a "user defined" u32 register; here: virt acc of config data
uint32_t *pSharedConfData;              // pointer to a "user defined" u32 register; here: config data
uint32_t *pSharedConfFlag;              // pointer to a "user defined" u32 register; here: config flags
uint32_t *pSharedConfPz;                // pointer to a "user defined" u32 register; here: PZ bit field (bit N is set: transsaction for PZ N)

uint32_t *pCpuRamExternal;              // external address (seen from host bridge) of this CPU's RAM            
uint32_t *pCpuRamExternalData4EB;       // external address (seen from host bridge) of this CPU's RAM: field for EB return values

uint32_t sumStatus;                     // all status infos are ORed bit-wise into sum status, sum status is then published
uint32_t nBadStatus;                    // # of bad status (=error) incidents
uint32_t nBadState;                     // # of bad state (=FATAL, ERROR, UNKNOWN) incidents
int32_t  dtMax;                         // dT max (deadline - dispatch time)
int32_t  dtMin;                         // dT min (deadline - dispatch time)
uint32_t nLate;                         // # of late messages
uint32_t vaccAvg;                       // virt accs played over the past second
uint32_t pzAvg;                         // PZs used over the past second
uint32_t mode;                          // 1: test mode
uint32_t nCycleAct;                     // number of cycles
uint32_t nCyclePrev;                    // previous number of cycles
uint64_t nMsgAct;                       // # of messages sent
uint64_t nMsgPrev;                      // previous number of messages
uint64_t tSyncPrev;                     // timestamp of previous 50Hz sync event from SPZ


// big data contains the event tables for all PZs, and for all virtual accelerators
// there are two sets of 16 virtual accelerators ('Kanal0' and 'Kanal1')
dataTable bigData[B2BTEST_NPZ][B2BTEST_NVACC * B2BTEST_NCHN];
uint32_t  vaccNext[B2BTEST_NPZ];

uint32_t gid[] =                 {1000, 1001, 1002, 1003, 1004, 1005, 1006};              /* hackish: GIDs for PZs, to be clarified with Hanno */
                                                                        
uint64_t wrGetMac() // get my own MAC
{
  uint32_t macHi, macLo;
  uint64_t mac;

  macHi = (*(pWREp + (WR_ENDPOINT_MACHI >> 2))) & 0xffff;
  macLo = *(pWREp + (WR_ENDPOINT_MACLO >> 2));

  mac = macHi;
  mac = (mac << 32);
  mac = mac + macLo;

  return mac;
} // wrGetMac


uint32_t ebmInit(uint32_t msTimeout, uint64_t dstMac, uint32_t dstIp, uint32_t eb_ops) // intialize Etherbone master
{
  uint64_t timeoutT;

  // check IP
  timeoutT = getSysTime() + (uint64_t)msTimeout * (uint64_t)1000000;
  while (timeoutT < getSysTime()) {
    if (*(pEbCfg + (EBC_SRC_IP>>2)) == EBC_DEFAULT_IP) asm("nop");
    else break;
  } // while no IP via DHCP
  if (*(pEbCfg + (EBC_SRC_IP>>2)) == EBC_DEFAULT_IP) return B2BTEST_STATUS_NOIP;

  // init ebm
  ebm_init();
  ebm_config_if(DESTINATION, dstMac    , dstIp,                       0xebd0); 
  ebm_config_if(SOURCE,      wrGetMac(), *(pEbCfg + (EBC_SRC_IP>>2)), 0xebd0); 
  ebm_config_meta(1500, 0x0, eb_ops);
  ebm_clr();

  return B2BTEST_STATUS_OK;
} // ebminit


uint32_t data2TM(uint32_t *idLo, uint32_t *idHi, uint32_t *paramLo, uint32_t *paramHi, uint32_t *res, uint32_t *tef, uint32_t *offset, uint32_t data, uint32_t gid, uint32_t virtAcc)  //converts event UNILAC event data to timing message
{
  uint32_t  t;
  uint32_t  evtCode;
  uint32_t  status;

  t        = (uint32_t)((data >> 16) & 0xffff);      // get time relative to begining of UNILAC cycle [us]
  evtCode  = (uint32_t)(data & 0xff);                // get event number
  status   = (uint32_t)((data >> 6) & 0xff);         // get status info

  *idHi     = (uint32_t)(                            // EventID
                          0x1     << 28     |        // FID = 1
                         (gid     << 16)    |        // GID
                         (evtCode <<  4)    |        // EVTNO
                          0x0                        // flags
                        );
  *idLo     = (uint32_t)(
                         (virtAcc << 20)    |        // SID
                         (0x0     <<  6)    |        // BPID
                         (0x0     <<  5)    |        // reserved
                         (0x0     <<  4)    |        // reqNoBeam
                          0x0                        // virtAcc only for DM-UNIPZ gateway
                        );
  *paramLo  = status;                                // parameter field  /* chk, probably rquires Hanno */ 
  *paramHi  = 0x0;                                
  *res      = 0x0;                                   // reserved
  *tef      = 0x0;                                   // timing extension field
  *offset   = t * 1000;                              // convert offset -> ns
} // data2TM


uint32_t ebmWriteTM(dataTable evts, uint64_t tStart, uint32_t pz, uint32_t virtAcc, uint32_t isPrep)
{
  int      i;
  uint64_t deadline;
  uint32_t res, tef;
  uint32_t deadlineLo, deadlineHi, offset;
  uint32_t idLo, idHi;
  uint32_t paramLo, paramHi;
  int32_t  tDiff;

  // set high bits for EB master
  ebm_hi(B2BTEST_ECA_ADDRESS);

  // pack Ethernet frame with messages
  for (i=0; i<B2BTEST_NEVT; i++) {                     // loop over all data fields
    if ((evts.validFlags >> i) & 0x1) {                // data is valid?
      if ((evts.evtFlags >> i) & 0x1) {                // data is an event?
        if (((evts.prepFlags >> i) & 0x1) == isPrep) { // data matches 'isPrep condition'
          // convert data
          data2TM(&idLo, &idHi, &paramLo, &paramHi, &res, &tef, &offset, evts.data[i], gid[pz], virtAcc);  //convert data
            
          // calc deadline
          deadline   = tStart + (uint64_t)offset; 
          deadlineHi = (uint32_t)((deadline >> 32) & 0xffffffff);
          deadlineLo = (uint32_t)(deadline & 0xffffffff);
          
          // pack timing message
          atomic_on();                                  
          ebm_op(B2BTEST_ECA_ADDRESS, idHi,       EBM_WRITE);             
          ebm_op(B2BTEST_ECA_ADDRESS, idLo,       EBM_WRITE);             
          ebm_op(B2BTEST_ECA_ADDRESS, paramHi,    EBM_WRITE);
          ebm_op(B2BTEST_ECA_ADDRESS, paramLo,    EBM_WRITE);
          ebm_op(B2BTEST_ECA_ADDRESS, tef,        EBM_WRITE);
          ebm_op(B2BTEST_ECA_ADDRESS, res,        EBM_WRITE);
          ebm_op(B2BTEST_ECA_ADDRESS, deadlineHi, EBM_WRITE);
          ebm_op(B2BTEST_ECA_ADDRESS, deadlineLo, EBM_WRITE);
          atomic_off();

          // send timing message
          ebm_flush();
          
          // diag and status
          tDiff = deadline - getSysTime();
          if (tDiff < 0    ) nLate++;
          if (tDiff < dtMin) dtMin = tDiff;
          if (tDiff > dtMax) dtMax = tDiff;

          vaccAvg = vaccAvg | (1 << virtAcc);
          pzAvg   = pzAvg   | (1 << pz);
          nMsgAct++;
        } // if 'isPrep'
      } // is event
    } // is valid
  } // for i

  return B2BTEST_STATUS_OK;
} //ebmWriteTM


uint32_t wrCheckSyncState() //check status of White Rabbit (link up, tracking)
{
  uint32_t syncState;

  syncState =  *(pPPSGen + (WR_PPS_GEN_ESCR >> 2));                         // read status
  syncState = syncState & WR_PPS_GEN_ESCR_MASK;                             // apply mask

  if ((syncState == WR_PPS_GEN_ESCR_MASK)) return B2BTEST_STATUS_OK;        // check if all relevant bits are set
  else                                     return B2BTEST_STATUS_WRBADSYNC;
} //wrCheckStatus


void init() // typical init for lm32
{
  discoverPeriphery();        // mini-sdb ...
  uart_init_hw();             // needed by WR console   
  cpuId = getCpuIdx();

  timer_init(1);              // needed by usleep_init() 
  usleep_init();              // needed by scu_mil.c

  // set MSI IRQ handler
  isr_table_clr();
  //irq_set_mask(0x01);
  irq_disable();
} // init


void initSharedMem() // determine address and clear shared mem
{
  uint32_t idx;
  uint32_t *pSharedTemp;
  int      i; 
  const uint32_t c_Max_Rams = 10;
  sdb_location found_sdb[c_Max_Rams];
  sdb_location found_clu;
  
  // get pointer to shared memory
  pShared           = (uint32_t *)_startshared;

  // get address to data
  pSharedVersion          = (uint32_t *)(pShared + (B2BTEST_SHARED_VERSION >> 2));
  pSharedSumStatus        = (uint32_t *)(pShared + (B2BTEST_SHARED_SUMSTATUS >> 2));
  pSharedCmd              = (uint32_t *)(pShared + (B2BTEST_SHARED_CMD >> 2));
  pSharedState            = (uint32_t *)(pShared + (B2BTEST_SHARED_STATE >> 2));
  pSharedData4EB          = (uint32_t *)(pShared + (B2BTEST_SHARED_DATA_4EB >> 2));
  pSharedNBadStatus       = (uint32_t *)(pShared + (B2BTEST_SHARED_NBADSTATUS >> 2));
  pSharedNBadState        = (uint32_t *)(pShared + (B2BTEST_SHARED_NBADSTATE >> 2));
  pSharedMacHi            = (uint32_t *)(pShared + (B2BTEST_SHARED_MACHI >> 2));
  pSharedMacLo            = (uint32_t *)(pShared + (B2BTEST_SHARED_MACLO >> 2));
  pSharedIp               = (uint32_t *)(pShared + (B2BTEST_SHARED_IP >> 2));
  pSharedNMessageHi       = (uint32_t *)(pShared + (B2BTEST_SHARED_NMESSAGEHI >> 2));
  pSharedNMessageLo       = (uint32_t *)(pShared + (B2BTEST_SHARED_NMESSAGELO >> 2));
  pSharedMsgFreqAvg       = (uint32_t *)(pShared + (B2BTEST_SHARED_MSGFREQAVG >> 2));
  pSharedDtMax            = (uint32_t *)(pShared + (B2BTEST_SHARED_DTMAX >> 2));
  pSharedDtMin            = (uint32_t *)(pShared + (B2BTEST_SHARED_DTMIN >> 2));
  pSharedNLate            = (uint32_t *)(pShared + (B2BTEST_SHARED_NLATE >> 2));
  pSharedVaccAvg          = (uint32_t *)(pShared + (B2BTEST_SHARED_VACCAVG >> 2));
  pSharedPzAvg            = (uint32_t *)(pShared + (B2BTEST_SHARED_PZAVG >> 2));
  pSharedMode             = (uint32_t *)(pShared + (B2BTEST_SHARED_MODE >> 2));
  pSharedTDiagHi          = (uint32_t *)(pShared + (B2BTEST_SHARED_TDIAGHI >> 2));
  pSharedTDiagLo          = (uint32_t *)(pShared + (B2BTEST_SHARED_TDIAGLO >> 2));
  pSharedTS0Hi            = (uint32_t *)(pShared + (B2BTEST_SHARED_TS0HI >> 2));
  pSharedTS0Lo            = (uint32_t *)(pShared + (B2BTEST_SHARED_TS0LO >> 2));
  pSharedConfStat         = (uint32_t *)(pShared + (B2BTEST_SHARED_CONF_STAT >> 2));
  pSharedConfVacc         = (uint32_t *)(pShared + (B2BTEST_SHARED_CONF_VACC >> 2));
  pSharedConfData         = (uint32_t *)(pShared + (B2BTEST_SHARED_CONF_DATA >> 2));
  pSharedConfFlag         = (uint32_t *)(pShared + (B2BTEST_SHARED_CONF_FLAG >> 2));
  pSharedConfPz           = (uint32_t *)(pShared + (B2BTEST_SHARED_CONF_PZ >> 2));
  
  // find address of CPU from external perspective
  idx = 0;
  find_device_multi(&found_clu, &idx, 1, GSI, LM32_CB_CLUSTER);	
  idx = 0;
  find_device_multi_in_subtree(&found_clu, &found_sdb[0], &idx, c_Max_Rams, GSI, LM32_RAM_USER);
  if(idx >= cpuId) {
    pCpuRamExternal           = (uint32_t *)(getSdbAdr(&found_sdb[cpuId]) & 0x7FFFFFFF); // CPU sees the 'world' under 0x8..., remove that bit to get host bridge perspective
    pCpuRamExternalData4EB    = (uint32_t *)(pCpuRamExternal + ((B2BTEST_SHARED_DATA_4EB + SHARED_OFFS) >> 2));
  }

  DBPRINT2("b2b-test: CPU RAM External 0x%8x, begin shared 0x%08x\n", pCpuRamExternal, SHARED_OFFS);

  // clear shared mem
  i = 0;
  pSharedTemp          = (uint32_t *)(pShared + (B2BTEST_SHARED_BEGIN >> 2 ));
  while (pSharedTemp < (uint32_t *)(pShared + (B2BTEST_SHARED_END >> 2 ))) {
    *pSharedTemp = 0x0;
    pSharedTemp++;
    i++;
  } // while pSharedTemp
  DBPRINT2("b2b-test: used size of shared mem is %d words (uint32_t), begin %x, end %x\n", i, pShared, pSharedTemp-1);
  
  // set initial values;
  *pSharedVersion      = B2BTEST_FW_VERSION; // of all the shared variabes, only VERSION is a constant. Set it now!
  *pSharedNBadStatus   = 0;
  *pSharedNBadState    = 0;
  *pSharedConfStat     = B2BTEST_CONFSTAT_IDLE;
} // initSharedMem 


uint32_t findMILPiggy() //find WB address of MIL Piggy
{
  pMILPiggy = 0x0;
  
  // get Wishbone address for MIL Piggy
  pMILPiggy = find_device_adr(GSI, SCU_MIL);

  if (!pMILPiggy) {DBPRINT1("b2b-test: can't find MIL piggy\n"); return B2BTEST_STATUS_ERROR;}
  else                                                           return B2BTEST_STATUS_OK;
} // findMILPiggy


uint32_t findPPSGen() //find WB address of WR PPS Gen
{
  pPPSGen = 0x0;
  
  // get Wishbone address for PPS Gen
  pPPSGen = find_device_adr(CERN, WR_PPS_GEN);

  if (!pPPSGen) {DBPRINT1("b2b-test: can't find WR PPS Gen\n"); return B2BTEST_STATUS_ERROR;}
  else                                                          return B2BTEST_STATUS_OK;
} // findPPSGen


uint32_t findWREp() //find WB address of WR Endpoint
{
  pWREp = 0x0;
  
  // get Wishbone address for WR Endpoint
  pWREp = find_device_adr(CERN, WR_ENDPOINT);

  if (!pWREp) {DBPRINT1("b2b-test: can't find WR Endpoint\n"); return B2BTEST_STATUS_ERROR;}
  else                                                         return B2BTEST_STATUS_OK;
} // findWREp


uint32_t findECAQueue() // find WB address of ECA channel for LM32
{
#define ECAQMAX           4     // max number of ECA channels in the system
#define ECACHANNELFORLM32 2     // this is a hack! suggest implementing finding via sdb-record and info

  // stuff below needed to get WB address of ECA queue
  sdb_location ECAQ_base[ECAQMAX];
  uint32_t ECAQidx = 0;         
  uint32_t *tmp;                
  int i;

  // get Wishbone address of ECA queue 
  // get list of ECA queues
  find_device_multi(ECAQ_base, &ECAQidx, ECAQMAX, ECA_QUEUE_SDB_VENDOR_ID, ECA_QUEUE_SDB_DEVICE_ID);
  pECAQ = 0x0;

  // find ECA queue connected to ECA chanel for LM32
  for (i=0; i < ECAQidx; i++) {
    tmp = (uint32_t *)(getSdbAdr(&ECAQ_base[i]));  
    if ( *(tmp + (ECA_QUEUE_QUEUE_ID_GET >> 2)) == ECACHANNELFORLM32) pECAQ = tmp;
  }

  if (!pECAQ) {DBPRINT1("b2b-test: can't find ECA queue\n"); return B2BTEST_STATUS_ERROR;}
  else                                                       return B2BTEST_STATUS_OK;
} // findECAQueue


uint32_t wait4ECAEvent(uint32_t msTimeout, uint64_t *deadline, uint32_t *isLate)  // 1. query ECA for actions, 2. trigger activity
{
  uint32_t *pECAFlag;           // address of ECA flag
  uint32_t evtIdHigh;           // high 32bit of eventID   
  uint32_t evtIdLow;            // low 32bit of eventID    
  uint32_t evtDeadlHigh;        // high 32bit of deadline  
  uint32_t evtDeadlLow;         // low 32bit of deadline   
  uint32_t evtParamHigh;        // high 32 bit of parameter field
  uint32_t evtParamLow ;        // low 32 bit of parameter field
  uint32_t evtTef;              // 32 bit TEF field
  uint32_t actTag;              // tag of action           
  uint32_t nextAction;          // describes what to do next
  uint64_t timeoutT;            // when to time out


  pECAFlag    = (uint32_t *)(pECAQ + (ECA_QUEUE_FLAGS_GET >> 2));   // address of ECA flag

  timeoutT    = getSysTime() + (uint64_t)msTimeout * (uint64_t)1000000 + (uint64_t)1000; 
  
  while (getSysTime() < timeoutT) {
    if (*pECAFlag & (0x0001 << ECA_VALID)) {                        // if ECA data is valid

      // read data
      evtIdHigh    = *(pECAQ + (ECA_QUEUE_EVENT_ID_HI_GET >> 2));
      evtIdLow     = *(pECAQ + (ECA_QUEUE_EVENT_ID_LO_GET >> 2));
      evtDeadlHigh = *(pECAQ + (ECA_QUEUE_DEADLINE_HI_GET >> 2));
      evtDeadlLow  = *(pECAQ + (ECA_QUEUE_DEADLINE_LO_GET >> 2));
      actTag       = *(pECAQ + (ECA_QUEUE_TAG_GET >> 2));
      evtParamHigh = *(pECAQ + (ECA_QUEUE_PARAM_HI_GET >> 2));
      evtParamLow  = *(pECAQ + (ECA_QUEUE_PARAM_LO_GET >> 2));
      evtTef       = *(pECAQ + (ECA_QUEUE_TEF_GET >> 2));
      *isLate      = *pECAFlag & (0x0001 << ECA_LATE);

      *deadline    = ((uint64_t)evtDeadlHigh << 32) + (uint64_t)evtDeadlLow;
      
      // pop action from channel
      *(pECAQ + (ECA_QUEUE_POP_OWR >> 2)) = 0x1;

      // here: do s.th. according to tag
      switch (actTag) 
        {
        case B2BTEST_ECADO_MIL :
          nextAction = B2BTEST_ECADO_MIL;
          break;
        default: 
          nextAction = B2BTEST_ECADO_UNKOWN;
          break;
        } // switch

      return nextAction;

    } // if data is valid
  } // while not timed out

  return  B2BTEST_ECADO_TIMEOUT;
} // wait for ECA event


void initCmds() // init stuff for handling commands, trivial for now, will be extended
{
  //  initalize command value: 0x0 means 'no command'
  *pSharedCmd     = 0x0;
} // initCmds

 
void clearDiag() // clears all statistics
{
  uint64_t now;
  
  dtMax          = 0x80000000;
  dtMin          = 0x7fffffff;
  nLate          = 0;
  nCycleAct      = 0;
  nCyclePrev     = 0;
  nMsgAct        = 0;
  nMsgPrev       = 0;
  sumStatus      = 0;
  nBadStatus     = 0;

  now = getSysTime();
  *pSharedTDiagHi = (uint32_t)(now >> 32);
  *pSharedTDiagLo = (uint32_t)now & 0xffffffff;

} // clearDiag

uint32_t configTransactInit()          // initializes transaction for config data
{
  int i,j;
  
  if (*pSharedConfStat != B2BTEST_CONFSTAT_IDLE) return B2BTEST_STATUS_TRANSACTION;

  *pSharedConfPz    = 0;
  *pSharedConfVacc  = 0;
  for (i=0; i < (B2BTEST_NCONFFLAG); i++) *(pSharedConfFlag   + i) = 0;
  for (i=0; i < (B2BTEST_NCONFDATA); i++) *(pSharedConfData   + i) = 0;

  DBPRINT2("b2b-test: request completed\n");
    
  *pSharedConfStat = B2BTEST_CONFSTAT_INIT;

  return B2BTEST_STATUS_OK;
} // configTransactInit

uint32_t configTransactSubmit() // submit transferred config data
{
  if (*pSharedConfStat != B2BTEST_CONFSTAT_INIT) return B2BTEST_STATUS_TRANSACTION;

  /* hack: code below shall be triggered by "commit" event from Masterpulszentrale */
  int      i,j,k;
  int      vacc;
  uint32_t pzFlag;

  // get vacc and submit flags
  vacc    = *pSharedConfVacc;
  pzFlag  = *pSharedConfPz;

  for (i=0; i < B2BTEST_NPZ; i++) {        // for all Pulszentralen
    for (j=0; j < B2BTEST_NCHN; j++) {     // for all channels
      if (pzFlag & (1 << i)) {             // check, if Pulszentrale (defined by "i") shall be submitted
        // flags
        bigData[i][j * B2BTEST_NVACC + vacc].validFlags = *(pSharedConfFlag + j * B2BTEST_NFLAG + i * B2BTEST_NPZ * B2BTEST_NCHN + 0);
        bigData[i][j * B2BTEST_NVACC + vacc].prepFlags  = *(pSharedConfFlag + j * B2BTEST_NFLAG + i * B2BTEST_NPZ * B2BTEST_NCHN + 1);
        bigData[i][j * B2BTEST_NVACC + vacc].evtFlags   = *(pSharedConfFlag + j * B2BTEST_NFLAG + i * B2BTEST_NPZ * B2BTEST_NCHN + 2);

        // data
        for (k=0; k < B2BTEST_NEVT; k++) 
          bigData[i][j * B2BTEST_NVACC + vacc].data[k]  = *(pSharedConfData + j * B2BTEST_NEVT  + i * B2BTEST_NEVT * B2BTEST_NCHN + k);
      } // if submit flag
    } // for j
  } // for i
  /* end hack */

  DBPRINT2("b2b-test: submit completed\n");
  
  /* *pSharedConfDataStat = B2BTEST_CONFSTAT_REQ | B2BTEST_CONFSTAT_SUBMIT; commented: this shall be used once code above is triggered by event */
  *pSharedConfStat = B2BTEST_CONFSTAT_IDLE;

  return B2BTEST_STATUS_OK;
} // configTransactSubmit


void clearPZ()
{
  int i,j,k;

  for (i=0; i < B2BTEST_NPZ; i++)
    for (j=0; j < (B2BTEST_NVACC * B2BTEST_NCHN); j++) {
      bigData[i][j].validFlags = 0x0;
      bigData[i][j].prepFlags  = 0x0;
      bigData[i][j].evtFlags   = 0x0;
      for (k=0; k < B2BTEST_NEVT; k++) bigData[i][j].data[k] = 0x0;
    } // for j
} // clear PZ


uint32_t doActionS0()
{
  uint32_t status = B2BTEST_STATUS_OK;
  uint64_t now;

  if (findECAQueue() != B2BTEST_STATUS_OK) status = B2BTEST_STATUS_ERROR; 
  if (findMILPiggy() != B2BTEST_STATUS_OK) status = B2BTEST_STATUS_ERROR;
  if (findPPSGen()   != B2BTEST_STATUS_OK) status = B2BTEST_STATUS_ERROR;
  if (findWREp()     != B2BTEST_STATUS_OK) status = B2BTEST_STATUS_ERROR;

  nBadState     = 0;
  mode          = B2BTEST_MODE_SPZ;
  now           = getSysTime();
  *pSharedTS0Hi = (uint32_t)(now >> 32);
  *pSharedTS0Lo = (uint32_t)now & 0xffffffff;
  
  initCmds();                    

  return status;
} // doActionS0


uint32_t entryActionConfigured()
{
  uint32_t status = B2BTEST_STATUS_OK;
  uint64_t mac;
  uint32_t ip;

  // configure EB master (SRC and DST MAC/IP are set from host)
  //  ebmInit(100, 0xffffffffffff, 0xffffffff, EBM_NOREPLY);
  if ((status = ebmInit(2000, 0xffffffffffff, 0xffffffff, EBM_NOREPLY)) != B2BTEST_STATUS_OK) {
    DBPRINT1("b2b-test: ERROR - init of EB master failed! %d\n", status);
    return status;
  } 

  // get and publish NIC data
  mac = wrGetMac();
  *pSharedMacHi = (uint32_t)(mac >> 32) & 0xffff;
  *pSharedMacLo = (uint32_t)mac         & 0xffffffff;

  ip  = *(pEbCfg + (EBC_SRC_IP>>2));
  *pSharedIp    = ip;

  *pSharedConfStat = B2BTEST_CONFSTAT_IDLE; /* chk */
  mode             = B2BTEST_MODE_SPZ;
  return status;
} // entryActionConfigured


uint32_t entryActionOperation()
{
  int      i;
  uint64_t tDummy;
  uint32_t flagDummy;
  
  clearDiag();                                               // clear diagnostics

  // flush ECA queue for lm32
  i = 0;
  while (wait4ECAEvent(1, &tDummy, &flagDummy) !=  B2BTEST_ECADO_TIMEOUT) {i++;}
  DBPRINT1("b2b-test: ECA queue flushed - removed %d pending entries from ECA queue\n", i);

  return B2BTEST_STATUS_OK;
} // entryActionOperation


uint32_t exitActionOperation(){
  return B2BTEST_STATUS_OK;
} // exitActionOperation

uint32_t exitActionError()
{
  return B2BTEST_STATUS_OK;
} // exitActionError


void cmdHandler(uint32_t *reqState) // handle commands from the outside world
{
  uint32_t cmd;

  cmd = *pSharedCmd;
  // check, if the command is valid and request state change
  if (cmd) {
    switch (cmd) {
    case B2BTEST_CMD_CONFIGURE :
      *reqState =  B2BTEST_STATE_CONFIGURED;
      DBPRINT3("b2b-test: received cmd %d\n", cmd);
      break;
    case B2BTEST_CMD_STARTOP :
      *reqState = B2BTEST_STATE_OPREADY;
      DBPRINT3("b2b-test: received cmd %d\n", cmd);
      break;
    case B2BTEST_CMD_STOPOP :
      *reqState = B2BTEST_STATE_STOPPING;
      DBPRINT3("b2b-test: received cmd %d\n", cmd);
      break;
    case B2BTEST_CMD_IDLE :
      *reqState = B2BTEST_STATE_IDLE;
      DBPRINT3("b2b-test: received cmd %d\n", cmd);
      break;
    case B2BTEST_CMD_RECOVER :
      *reqState = B2BTEST_STATE_IDLE;
      DBPRINT3("b2b-test: received cmd %d\n", cmd);
      break;
    case B2BTEST_CMD_CLEARDIAG :
      DBPRINT3("b2b-test: received cmd %d\n", cmd);
      clearDiag();
      break;
    case B2BTEST_CMD_CONFINIT :
      DBPRINT3("b2b-test: received cmd %d\n", cmd);
      if (configTransactInit() != B2BTEST_STATUS_OK) DBPRINT1("b2b-test: request to start config data transaction failed\n");
      break;
    case B2BTEST_CMD_CONFSUBMIT :
      DBPRINT3("b2b-test: received cmd %d\n", cmd);
      if (configTransactSubmit() != B2BTEST_STATUS_OK) DBPRINT1("b2b-test: submission of config data failed\n");
      break;
    case B2BTEST_CMD_CONFKILL :
      DBPRINT3("b2b-test: received cmd %d\n", cmd);
      *pSharedConfStat = B2BTEST_CONFSTAT_IDLE;
      break;     
    case B2BTEST_CMD_CONFCLEAR :
      DBPRINT3("b2b-test: received cmd %d\n", cmd);
      clearPZ();
      break;
    case B2BTEST_CMD_MODESPZ :
      DBPRINT3("b2b-test: received cmd %d\n", cmd);
      mode = B2BTEST_MODE_SPZ;
      break;
    case B2BTEST_CMD_MODETEST :
      DBPRINT3("b2b-test: received cmd %d\n", cmd);
      mode = B2BTEST_MODE_TEST;
      break;
    default:
      DBPRINT3("b2b-test: received unknown command '0x%08x'\n", cmd);
    } // switch 
    *pSharedCmd = 0x0; // reset cmd value in shared memory 
  } // if command 
} // cmdHandler


uint32_t changeState(uint32_t *actState, uint32_t *reqState, uint32_t actStatus)   //state machine; see b2b-test.h for possible states and transitions
{
  uint32_t statusTransition= B2BTEST_STATUS_OK;
  uint32_t status;
  uint32_t nextState;                   

  // if something severe happened, perform implicitely allowed transition to ERROR or FATAL states
  // else                        , handle explicitcely allowed transitions

  if ((*reqState == B2BTEST_STATE_ERROR) || (*reqState == B2BTEST_STATE_FATAL)) {statusTransition = actStatus; nextState = *reqState;}
  else {
    nextState = *actState;                       // per default: remain in actual state without exit or entry action
    switch (*actState) {                         // check for allowed transitions: 1. determine next state, 2. perform exit or entry actions if required
    case B2BTEST_STATE_S0:
      if      (*reqState == B2BTEST_STATE_IDLE)       {                                            nextState = *reqState;}      
      break;
    case B2BTEST_STATE_IDLE:
      if      (*reqState == B2BTEST_STATE_CONFIGURED)  {statusTransition = entryActionConfigured(); nextState = *reqState;}
      break;
    case B2BTEST_STATE_CONFIGURED:
      if      (*reqState == B2BTEST_STATE_IDLE)       {                                            nextState = *reqState;}
      else if (*reqState == B2BTEST_STATE_CONFIGURED) {statusTransition = entryActionConfigured(); nextState = *reqState;}
      else if (*reqState == B2BTEST_STATE_OPREADY)    {statusTransition = entryActionOperation();  nextState = *reqState;}
      break;
    case B2BTEST_STATE_OPREADY:
      if      (*reqState == B2BTEST_STATE_STOPPING)   {statusTransition = exitActionOperation();   nextState = *reqState;}
      break;
    case B2BTEST_STATE_STOPPING:
      nextState = B2BTEST_STATE_CONFIGURED;      //automatic transition but without entryActionConfigured
    case B2BTEST_STATE_ERROR:
      if      (*reqState == B2BTEST_STATE_IDLE)       {statusTransition = exitActionError();       nextState = *reqState;}
      break;
    default: 
      nextState = B2BTEST_STATE_S0;
    } // switch actState
  }  // else something severe happened
  
  // if the transition failed, transit to error state (except we are already in FATAL state)
  if ((statusTransition != B2BTEST_STATUS_OK) && (nextState != B2BTEST_STATE_FATAL)) nextState = B2BTEST_STATE_ERROR;

  // if the state changes
  if (*actState != nextState) {                   
    mprintf("b2b-test: changed to state %d\n", nextState);
    *actState = nextState;                      
    status = statusTransition;
  } // if state change
  else  status = actStatus;

  *reqState = B2BTEST_STATE_UNKNOWN;             // reset requested state (= no change state requested)  

  return status;
} //changeState


uint32_t doActionOperation(uint32_t *nCycle,                  // total number of UNILAC cycle since FW start
                           uint64_t *tAct,                    // actual time
                           uint32_t actStatus)                // actual status of firmware
{
  uint32_t status;                                            // status returned by routines
  uint32_t flagIsLate;                                        // flag indicating that we received a 'late' event from ECA
  uint32_t ecaAction;                                         // action triggered by event received from ECA
  uint64_t deadline;                                          // deadline of event received via ECA
  uint64_t tMIL;                                              // time when MIL event was received
  uint64_t tDummy;                                            // dummy timestamp
  uint16_t evtData;                                           // MIL event: data
  uint16_t evtCode;                                           // MIL event: code
  uint32_t virtAcc;                                           // MIL event: virtAcc
  uint32_t milStatus;                                         // status for receiving of MIL events
  uint32_t nLateLocal;                                        // remember actual counter
  uint32_t isPrepFlag;                                        // flag 'isPrep': prep-events are sent immediately, non-prep-events are sent at 50 Hz trigger
  int      i,j;


  status = actStatus;
  
  evtCode = 0xffff; /* chk */
  
  switch (evtCode) {

  case B2BTEST_EVT_50HZ_SYNCH :                                // next UNILAC cycle starts
    (*nCycle)++;
    DBPRINT3("b2b-test: 50Hz, data %d, evtcode %d, virtAcc %d\n", evtData, evtCode, virtAcc);

    // get timestamp from TLU -> ECA
    ecaAction = wait4ECAEvent(B2BTEST_ECATIMEOUT, &deadline, &flagIsLate);
    
    // check, if timestamping via TLU failed
    if (ecaAction == B2BTEST_ECADO_TIMEOUT) {      
      deadline = tMIL;                                          // continue with TS from MIL
      status   = B2BTEST_STATUS_NOTIMESTAMP;
    } // if ecaAction
    
    // check, if timestamps form TLU and MIL are out of order
    if (deadline > tMIL) {
      deadline = tMIL;                                          // continue with TS from MIL
      status   = B2BTEST_STATUS_ORDERTIMESTAMP;
    } // if deadline
    
    // check, if timestamp from TLU is not reasonable
    if ((tMIL - deadline) > B2BTEST_MATCHWINDOW) {
      deadline = tMIL;                                          // continue with TS from MIL
      status   = B2BTEST_STATUS_BADTIMESTAMP;
    } // if tMIL
    

    ebm_clr();

    // walk through all PZs and run requested virt acc (non-prep events)
    nLateLocal = nLate;                                        // for bookkepping for late messages
    isPrepFlag = 0;                                            // 50 Hz synch: no preperation - use actual deadline from TLU
    for (i=0; i < B2BTEST_NPZ; i++) {
      if (vaccNext[i] != 0xffffffff) {
        ebmWriteTM(bigData[i][vaccNext[i]], deadline, i, vaccNext[i], isPrepFlag);
        DBPRINT3("b2b-test: playing pz %d, vacc %d\n", i, vaccNext[i]);
      } // if vaccNext
    } // for i
    if ((nLate != nLateLocal) && (status == B2BTEST_STATUS_OK)) status = B2BTEST_STATUS_LATE;
    *tAct = deadline;                                           // remember 50 Hz tick
    DBPRINT3("b2b-test: vA played:  %x %x %x %x %x %x %x\n", vaccNext[0], vaccNext[1], vaccNext[2], vaccNext[3], vaccNext[4], vaccNext[5], vaccNext[6]);

    // reset requested virt accs; flush ECA queue
    for (i=0; i < B2BTEST_NPZ; i++) vaccNext[i] = 0xffffffff;   // 0xffffffff: no virt acc for PZ
    DBPRINT3("b2b-test: vA reset:  %x %x %x %x %x %x %x\n", vaccNext[0], vaccNext[1], vaccNext[2], vaccNext[3], vaccNext[4], vaccNext[5], vaccNext[6]);
    while (wait4ECAEvent(0, &tDummy, &flagIsLate) !=  B2BTEST_ECADO_TIMEOUT) {asm("nop");}
    
    break;
  case B2BTEST_EVT_PZ1 ... B2BTEST_EVT_PZ7 :                    // announce what happens in next UNILAC cycle
    vaccNext[evtCode-1] = virtAcc;                              // PZ: sPZ counts from 1..7, we count from 0..6
    DBPRINT3("b2b-test: vA set:  %x %x %x %x %x %x %x\n", vaccNext[0], vaccNext[1], vaccNext[2], vaccNext[3], vaccNext[4], vaccNext[5], vaccNext[6]);

    nLateLocal = nLate;
    isPrepFlag = 1;                                             // PZ1..7: preperation - use deadline from past 50 Hz tick
    deadline   = tSyncPrev + (uint64_t)B2BTEST_UNILACPERIOD;
    ebmWriteTM(bigData[evtCode - 1][virtAcc], deadline, evtCode - 1, virtAcc, isPrepFlag);
    DBPRINT3("b2b-test: playing pz %d, vacc %d\n", i, virtAcc);
    if ((nLate != nLateLocal) && (status == B2BTEST_STATUS_OK)) status = B2BTEST_STATUS_LATE;

    break;
  default :
    break;
  } // switch evtCode

  return status;
} // doActionOperation

uint32_t doAutoRecovery(uint32_t actState, uint32_t *reqState)                    // do autorecovery from error state
{
  switch (actState)
    {
    case B2BTEST_STATE_ERROR :
      DBPRINT3("b2b-test: attempting autorecovery ERROR -> IDLE\n");
      usleep(10000000);
      *reqState = B2BTEST_STATE_IDLE; 
      break;
    case B2BTEST_STATE_IDLE :
      DBPRINT3("b2b-test: attempting autorecovery IDLE -> CONFIGURED\n");
      usleep(5000000);
      *reqState =  B2BTEST_STATE_CONFIGURED;
      break;
    case B2BTEST_STATE_CONFIGURED :
      DBPRINT3("b2b-test: attempting autorecovery CONFIGURED -> OPREADY\n");
      usleep(5000000);
      *reqState =  B2BTEST_STATE_OPREADY;
      break;
    default : ;
    } // switch actState
} // doAutoRecovery


void main(void) {
 
  uint32_t j;
 
  uint64_t tPrevCycle;                          // time of previous UNILAC cycle
  uint64_t tActCycle;                           // time of actual UNILAC cycle
  uint32_t status;                              // (error) status
  uint32_t actState;                            // actual FSM state
  uint32_t reqState;                            // requested FSM state
  uint32_t flagRecover;                         // flag indicating auto-recovery from error state;  

  mprintf("\n");
  mprintf("b2b-test: ***** firmware v %06d started from scratch *****\n", B2BTEST_FW_VERSION);
  mprintf("\n");
  
  // init local variables
  reqState       = B2BTEST_STATE_S0;
  actState       = B2BTEST_STATE_UNKNOWN;
  status         = B2BTEST_STATUS_OK;
  flagRecover    = 0;
  clearDiag();

  init();                                                                   // initialize stuff for lm32
  initSharedMem();                                                          // initialize shared memory
  
  while (1) {
    cmdHandler(&reqState);                                                  // check for commands and possibly request state changes
    status = B2BTEST_STATUS_OK;                                             // reset status for each iteration
    status = changeState(&actState, &reqState, status);                     // handle requested state changes
    switch(actState)                                                        // state specific do actions
      {
      case B2BTEST_STATE_S0 :
        status = doActionS0();                                              // important initialization that must succeed!
        if (status != B2BTEST_STATUS_OK) reqState = B2BTEST_STATE_FATAL;    // failed:  -> FATAL
        else                             reqState = B2BTEST_STATE_IDLE;     // success: -> IDLE
        break;
      case B2BTEST_STATE_OPREADY :
        flagRecover = 0;
        status = doActionOperation(&nCycleAct, &tActCycle, status);
        if (status == B2BTEST_STATUS_WRBADSYNC)      reqState = B2BTEST_STATE_ERROR;
        if (status == B2BTEST_STATUS_ERROR)          reqState = B2BTEST_STATE_ERROR;
        break;
      case B2BTEST_STATE_ERROR :
        flagRecover = 1;                                                    // start autorecovery
        break; 
      case B2BTEST_STATE_FATAL :
        *pSharedState     = actState;
        *pSharedSumStatus = sumStatus;
        mprintf("b2b-test: a FATAL error has occured. Good bye.\n");
        while (1) asm("nop"); // RIP!
        break;
      default :                                                             // avoid flooding WB bus with unnecessary activity
        for (j = 0; j < (B2BTEST_DEFAULT_TIMEOUT * B2BTEST_MS_ASMNOP); j++) { asm("nop"); }
      } // switch

    // autorecovery from state ERROR
    if (flagRecover) doAutoRecovery(actState, &reqState);

    // update shared memory
    // ... 
        
    nCyclePrev = nCycleAct;

    switch (status) {
    case B2BTEST_STATUS_OK :                                                  // status OK
      sumStatus = sumStatus |  (0x1 << B2BTEST_STATUS_OK);                    // set OK bit
      break;
    default :                                                                 // status not OK
      if ((sumStatus >> B2BTEST_STATUS_OK) & 0x1) nBadStatus++;               // changing status from OK to 'not OK': increase 'bad status count'
      sumStatus = sumStatus & ~(0x1 << B2BTEST_STATUS_OK);                    // clear OK bit
      sumStatus = sumStatus |  (0x1 << status);                               // set status bit and remember other bits set
      break;
    } // switch status

    if ((*pSharedState     == B2BTEST_STATE_OPREADY) && (actState  != B2BTEST_STATE_OPREADY)) nBadState++;
    *pSharedSumStatus    = sumStatus;
    *pSharedState        = actState;
    *pSharedNBadStatus   = nBadStatus;
    *pSharedNBadState    = nBadState;
    *pSharedDtMax        = dtMax;
    *pSharedDtMin        = dtMin;
    *pSharedNLate        = nLate;
    *pSharedMode         = mode;
    *pSharedNMessageHi   = (uint32_t)(nMsgAct >> 32);
    *pSharedNMessageLo   = (uint32_t)(nMsgAct & 0xffffffff);
  } // while  
} // main
