--! @file        xwb_serdes_clk_gen_auto.vhd
--  DesignUnit   xwb_serdes_clk_gen_auto
--! @author      Theodor Stana <>
--! @date        24/03/2015
--! @version     
--! @copyright   2015 GSI Helmholtz Centre for Heavy Ion Research GmbH
--!

--! @brief AUTOGENERATED WISHBONE-SLAVE CORE FOR xwb_serdes_clk_gen.vhd
--!
--------------------------------------------------------------------------------
--! This library is free software; you can redistribute it and/or
--! modify it under the terms of the GNU Lesser General Public
--! License as published by the Free Software Foundation; either
--! version 3 of the License, or (at your option) any later version.
--!
--! This library is distributed in the hope that it will be useful,
--! but WITHOUT ANY WARRANTY; without even the implied warranty of
--! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
--! Lesser General Public License for more details.
--!
--! You should have received a copy of the GNU Lesser General Public
--! License along with this library. If not, see <http://www.gnu.org/licenses/>.
--------------------------------------------------------------------------------

-- ***********************************************************
-- ** WARNING - THIS IS AUTO-GENERATED CODE! DO NOT MODIFY! **
-- ***********************************************************
--
-- If you want to change the interface,
-- modify xwb_serdes_clk_gen.xml and re-run 'python wbgenplus.py xwb_serdes_clk_gen.xml' !

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.wishbone_pkg.all;
use work.xwb_serdes_clk_gen_auto_pkg.all;

entity xwb_serdes_clk_gen_auto is
Port(
   clk_sys_i            : in  std_logic;
   clk_ref_i            : in  std_logic;
   rst_n_i              : in  std_logic;

   wbs_regs_clk_sys_o   : out t_wbs_regs_clk_sys_o;
   wbs_regs_clk_ref_o   : out t_wbs_regs_clk_ref_o;
   wbs_regs_clk_sys_i   : in  t_wbs_regs_clk_sys_i;
   wbs_i                : in  t_wishbone_slave_in;
   wbs_o                : out t_wishbone_slave_out
   
);
end xwb_serdes_clk_gen_auto;

architecture rtl of xwb_serdes_clk_gen_auto is

   --+******************************************************************************************+
   --|  ------------------------------------- WB Registers -------------------------------------|
   --+******************************************************************************************+

   --| WBS Regs ----------------------------- wbs ----------------------------------------------|
   signal r_wbs                  : t_wbs_regs_o;
   signal s_wbs                  : t_wbs_regs_i;
   signal r_wbs_out_stall        : std_logic;
   signal r_wbs_out_ack0,
          r_wbs_out_ack1,
          r_wbs_out_err0,
          r_wbs_out_err1         : std_logic;
   signal r_wbs_out_dat0,
          r_wbs_out_dat1         : std_logic_vector(31 downto 0);
   signal r_wbs_regs_clk_ref_o_0 : t_wbs_regs_clk_ref_o;
   signal r_wbs_regs_clk_ref_o_1 : t_wbs_regs_clk_ref_o;
   signal r_wbs_regs_clk_ref_o_2 : t_wbs_regs_clk_ref_o;



begin

   --+******************************************************************************************+
   --| Sync Signal Assignments ------- wbs -----------------------------------------------------|
   --+******************************************************************************************+
   -- wbs sys domain out
   wbs_regs_clk_sys_o.selr       <= r_wbs.selr;
   -- wbs sys domain in
   s_wbs.STALL                   <= wbs_regs_clk_sys_i.STALL;
   s_wbs.ERR                     <= wbs_regs_clk_sys_i.ERR;
   
   -- wbs ref domain out
   wbs_regs_clk_ref_o.hperr      <= r_wbs_regs_clk_ref_o_2.hperr;
   r_wbs_regs_clk_ref_o_0.hperr  <= r_wbs.hperr;
   wbs_regs_clk_ref_o.maskr      <= r_wbs_regs_clk_ref_o_2.maskr;
   r_wbs_regs_clk_ref_o_0.maskr  <= r_wbs.maskr;
   -- wbs ref domain in
   
   --+******************************************************************************************+
   --| Sync Processes -------------------- wbs -------------------------------------------------|
   --+******************************************************************************************+
   sync_wbs_clk_ref_out : process(clk_ref_i)
   begin
      if rising_edge(clk_ref_i) then
         if(rst_n_i = '0') then
         else
            r_wbs_regs_clk_ref_o_1  <= r_wbs_regs_clk_ref_o_0;
            r_wbs_regs_clk_ref_o_2  <= r_wbs_regs_clk_ref_o_1;
         end if; -- rst
      end if; -- clk edge
   end process;



   --+******************************************************************************************+
   --| WBS FSM ------------------------------- wbs ---------------------------------------------|
   --+******************************************************************************************+
   wbs : process(clk_sys_i)
      variable v_dat_i  : t_wishbone_data;
      variable v_dat_o  : t_wishbone_data;
      variable v_adr    : natural;
      variable v_page   : natural;
      variable v_sel    : t_wishbone_byte_select;
      variable v_we     : std_logic;
      variable v_en     : std_logic;
   begin
      if rising_edge(clk_sys_i) then
         if(rst_n_i = '0') then
            r_wbs.selr        <= (others => '0');
            r_wbs.hperr       <= (others =>(others => '0'));
            r_wbs.maskr       <= (others =>(others => '0'));
            r_wbs_out_stall   <= '0';
            r_wbs_out_ack0    <= '0';
            r_wbs_out_err0    <= '0';
            r_wbs_out_dat0    <= (others => '0');
            r_wbs_out_ack1    <= '0';
            r_wbs_out_err1    <= '0';
            r_wbs_out_dat1    <= (others => '0');
         else
            -- short names
            v_dat_i           := wbs_i.dat;
            v_adr             := to_integer(unsigned(wbs_i.adr(2 downto 2)) & "00");
            v_sel             := wbs_i.sel;
            v_en              := wbs_i.cyc and wbs_i.stb and not (r_wbs_out_stall or wbs_regs_clk_sys_i.STALL);
            v_we              := wbs_i.we;

            --interface outputs
            r_wbs_out_stall   <= '0';
            r_wbs_out_ack0    <= '0';
            r_wbs_out_err0    <= '0';
            r_wbs_out_dat0    <= (others => '0');

            r_wbs_out_ack1    <= r_wbs_out_ack0;
            r_wbs_out_err1    <= r_wbs_out_err0;
            r_wbs_out_dat1    <= r_wbs_out_dat0;

            
            if(v_en = '1') then
               r_wbs_out_ack0  <= '1';
               if(v_we = '1') then
                  -- WISHBONE WRITE ACTIONS
                  case v_adr is
                     when c_wbs_sel r_RW   => r_wbs.selr          <= f_wb_wr(r_wbs.selr,           v_dat_i, v_sel, "owr"); -- Selects which channel to control.
                     when c_wbs_hperr_RW  => r_wbs.hperr(v_page)  <= f_wb_wr(r_wbs.hperr(v_page),  v_dat_i, v_sel, "owr"); -- Half-period register
                     when c_wbs_maskr_RW  => r_wbs.maskr(v_page)  <= f_wb_wr(r_wbs.maskr(v_page),  v_dat_i, v_sel, "owr"); -- Bit flip mask register
                     when others => r_wbs_out_ack0 <= '0'; r_wbs_out_err0 <= '1';
                  end case;
               else
                  -- WISHBONE READ ACTIONS
                  case v_adr is
                     when c_wbs_selr_RW   => r_wbs_out_dat0(31 downto 0)   <= r_wbs.selr;          -- Selects which channel to control.
                     when c_wbs_hperr_RW  => r_wbs_out_dat0(31 downto 0)   <= r_wbs.hperr(v_page); -- Half-period register
                     when c_wbs_maskr_RW  => r_wbs_out_dat0(31 downto 0)   <= r_wbs.maskr(v_page); -- Bit flip mask register
                     when others => r_wbs_out_ack0 <= '0'; r_wbs_out_err0 <= '1';
                  end case;
               end if; -- v_we
            end if; -- v_en
         end if; -- rst
      end if; -- clk edge
   end process;

   wbs_o.stall <= r_wbs_out_stall or wbs_regs_clk_sys_i.STALL;
   wbs_o.dat   <= r_wbs_out_dat1;
   wbs_o.ack   <= r_wbs_out_ack1 and not wbs_regs_clk_sys_i.ERR;
   wbs_o.err   <= r_wbs_out_err1 or      wbs_regs_clk_sys_i.ERR;


end rtl;
